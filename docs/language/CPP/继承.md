# 继承

面向对象程序设计的四个主要特点：抽象、封住、继承、多态

继承性是面向对象程序设计最重要的特征

面向对象技术强调'**软件的可重用性**'（software reusability），Ｃ++语言提供了类的继承机制，解决了软件重用问题



## 1. 继承与派生的概念

Ｃ++中可重用性通过'**继承**'(inheritance)机制实现

在Ｃ++中继承就是在一个已存在的类的基础上建立一个新的类。

- 已存在的类被称为'**基类**'（base class）或'**父类**'（father class）
- 新建的类称为'**派生类**'（derived class）或'**子类**'（son class）
- '**子类型**'：必须是子类继承了父类所有的可继承特性（公有继承），才能说是子类型，否则是单纯的子类

-----------------



'**类的继承**'：一个新类从已有的类那里获得其他已有特性

- 通过继承，一个新建子类从已有的父类获得父类的特性

'**类的派生**'：从已有的类（父类）产生一个新的子类

- 类的继承是用已有的类来建立专用类的编程技术

----------------

类的'**继承层次结构**'  派生类继承了基类的所有数据成员和成员函数，并根据需要对成员做出必要的调整

- 类的每一次派生，都继承了其基类的基本特征，同时又有区别和发展
- 一个基类可以派生出多个派生类，每一个派生类又可以作为基类再派生出新的派生类
- 因此基类和派生类都是相对而言的。一代一代的派生下去，就形成了类的'**继承层次结构**'

继承具有'**传递性**'



-----------------------

**单继承**：一个派生类只从一个基类派生（继承最简单的情况），形成一个树形结构 

**多重继承**：一个派生类有两个或多个基类的称为'多重继承'（multiple inheritance）

- 理解：一个派生类还可以从多个基类派生（如马和驴子杂交骡），一个派生类可以有多个基类

派生类和基类的关系：**派生类是基类的具体化，基类是派生类的抽象**

- 基类综合了派生类的公共特征，派生类则在基类的基础上增加了某些特性，把抽象类变成具体的、实用的类型





## 2. 派生类的声明

单继承举例

```cpp
class Student{                                  //声明一个类Student
	public:
		void display(){
			cout<<"num: "<<num<<endl;
			cout<<"name: "<<name<<endl;
			cout<<"sex: "<<sex<<endl;
		}
	private:
		int num;
		string name;
		char sex;
};
class Student1:public Student{                 //声明基类是Student
	public:
		void display_1(){
			cout<<"age: "<<age<<endl;          //新增加的成员函数
			cout<<"address: "<<address<<endl;  
		}
	private:
		int age;                               //新增加的数据成员
		int address;                           //新增加的数据成员
};
```

说明 

-  在定义第二个类时，Student1 是新建的类名，冒号后面的 Student 表示是已声明的基类
- 在 Student 前的关键字`public`表示基类 Student 中的成员在派生类 Student1 中的'继承方式'
- 基类名前有 `public`的称为**公用继承**（public inheritance），此外还有**`private`(私有继承)**、**`protected`(保护继承)**
- 如果不写则**默认'私有继承'**

声明派生类的一般形式为

```cpp
class 派生类名:[继承方式]基类名
{
	派生类新增加的成员
};   //类声明分号结尾！！
```



## 3. 派生类的构成

派生类中的成员包括从基类继承过来的成员和自己增加的成员两大部分

- 从基类继承的成员体系类派生类从基类继承而获得的共性
- 新增加的成员体现了派生类的个性，（正是这些新增加的成员体现了派生类与基类的不同）
    - 派生类通过 添加新的成员 将其本身与基类区分开来

------------------

------------------

构造一个派生类包括三部分工作（并不少简单的把基类的成员和派生类自己增加的成员加在一起成为派生类）

1. **从基类接收成员**

- 派生类把基类的**全部**成员（不包括构造函数和析构函数、友元特性、赋值运算符重载函数 `=` ）接收过来，没有选择余地，不能接收一部分放弃一部分
- 在多次派生后会造成数据冗余问题，目前在Ｃ++中无法解决，所以要求慎重选择基类，考虑如何是派生类的结构更加合理
- 有些类是专门为基类设计的，在设计时充分考虑到了派生类的要求

2. **调整从基类接收的成员**

- 接收基类成员无法选择，但是能够对成员调整
- 例如通过指定继承方式调整基类成员在派生类中的访问属性
- 可以在派生类中声明一个与基类成员同名的成员，则派生类中的新成员会覆盖基类的同名成员

利用这种方法可以用新成员取代基类的成员

::: warning 注意

如果是成员函数应该使函数名和函数的参数表（参数的个数和类型相同），如果不同则是函数的重载而不是覆盖

:::

3. **在声明派生类是增加的成员**

- 增加的成员体现了派生类对基类的功能扩展，需要精心设计成员和函数
- 在声明派生类时，一般还应该自己定义派生类的构造函数和析构函数（构造函数和析构函数不能从基类继承）



::: tip 综上所述

派生类是基类定义的延续，通过对基类声明的延续，将一个抽象的基类转化为具体的派生类。因此，**派生类是抽象基类的具体实现**

:::



## 4. 派生类成员的访问属性

不同的继承方式决定了基类成员在派生类中的访问属性，一个成员在不同的派生层次中的访问属性可能是不同的

有以下几种访问情况需要讨论



## 5. 区分 派生类对象 和 派生类 对基类成员的访问权限

1. “派生类对象”对基类成员的访问权限：   
    - 对于公有继承，只有基类的公有成员可以被“派生类对象”访问，其他(保护和私有)成员不能被访问。   
    - 对于私有继承和保护继承，基类中所有成员都不能被“派生类对象”访问。  

2. “派生类”对基类中成员的访问权限：   
    - 对于公有继承，基类中的公有成员和保护成员可以被“派生类”访问，而基类中的私有成员不能被访问。   
    - 对私有继承和保护继承，也是基类中的公有成员和保护成员可以被“派生类”访问，而基类中的私有成员不能被访问。

