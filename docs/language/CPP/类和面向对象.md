#  类和面向对象

## 对象、面向对象

凡是以类对象为基本构成单位的程序称为基于对象的程序

> 面向对象的程序特点：抽象、封装、继承、多态性

类对象体现了c++的抽象与封装

1. **对象**：万物皆对象（object）

::: tip 对象的两个要素 

- 静态特征:'**属性**'(attribute)

- 动态特征:'**行为（或者功能）**'(behavior)

:::

从外部控制对象：发送一个信息:'**消息**'(message)

- 在一个系统中的多个对象之间通过一定的渠道互相联系

- 要是某一对象实现某一种行为（操作），应向它传送相应的消息

对象是由一组属性和一组行为构成的

C++中，每个对象都是由'**数据**'和'**函数**'构成的

2. **封装与信息隐蔽**

对一个对象进行封装处理，把它的一部分属性和功能对外界隐蔽

把对象的内部实现和外部行为分隔开

::: tip 封装性(encapsulation)

1. 将有关的数据和操作代码封装在一个对象中，形成一个基本单位，各个对象之间相互独立，互不干扰

2. 将对象中的某些部分对外隐蔽，即隐蔽基本细节，只保留少量接口，以便对外联系和接受信息。这种做法被称为信息隐蔽（imofrmation hiding）   //c++中函数名就是对外接口

:::

3. **抽象**

抽象的作用是表示同一类事物的本质

类是对象的抽象，而对象则是类的特例，即类的具体表现形式



4. **继承与重用**

继承机制:若已经建立了一个A类，再建立一个与A基本相同的Ｂ类，不必再从头设计一个新类，只需在A类的基础上增加新的内容

父类/基类

子类/派生类



5. **多态性**

- 多态现象：有几个相似但是不完全相同的对象，在向它们发送同一个消息时，它们的反应各不相同，分别执行不同的操作

- 多态性：由继承而产生的不同的派生类，其对象对同一消息会做出不同的响应。

- 多态性时面向对象程序设计的一个重要特征，能增加程序的灵活性



> *面向对象程序设计的特点
>
> 把数据和有关操作封装成一个对象
>
> 包括两个方面: 
>
> 1. 设计所需的各种类和对象，即决定把那些数据和操作封装在一起
>
> 2. 考虑如何向有关对象发送消息，以完成任务



## 类的声明、定义、引用

类是对象的抽象，对象是类的具体实例

类是对象的'模版'

类是抽象的，不占用内存；而对象是具体的，占用储存空间

### 声明类类型

  与声明结构体类型相似，一般形式为

```cpp
class 类名{
    private:
    私有的数据和成员函数
    public:
    公有的数据和成员函数
};  //有分号结尾！！！！
```

  说明 

- `private`和`public`是成员访问限定符，用来声明各成员的访问属性。
    - 被声明为私有的成员，只能被本类中的成员函数引用，类外的不能调用(友元类除外)

- 还有一种成员限定符' `protected`'，不能被类外访问，但是能被'派生类'成员函数访问
- 声明`private`、`public`、`protected`时没有规定的顺序，访问限定符也可以出现多次（最好一次）
- 如果没有任何声明，默认'`private`'



### 定义对象



  1、先声明类类型，然后在定义对象,eg

```cpp
Student stud1,stud2;  //Student是已经声明过的类类型
```

或者

```cpp
class Student stud1,stud2;  //标准c继承下来的写法，c++种可以像上一种一样不加class更简单
```

  2、在声明类的同时定义对象,eg

```cpp
class Student{
    public:
        void display(){
            cout << "num" << num << '\n'
                << "name" << name << '\n'
                << "gender" << gender << endl;
        }

    private:
        int num;
        char name[20];
        char gender;

}stud1,stud2;   //在这里定义两个类对象，别忘了分号
```

  3、不出现类名，直接定义对象eg：

```cpp
class{
    private:
    	......
    public:
    	......
}stud1,stud2;
```

​    不提倡使用这种方法



### 类的成员函数

性质：  

- 是函数的一种，简称类函数
- 属于类的成员，调用时注意权限
- 对外接口：需要被外界调用的函数应指定为`public`
- 工具函数：为本类中的成员函数调用，是类中其他成员的工具函数，应设置为`private`

#### 在类外定义成员函数

```cpp
class Student{
    public:
    void display();  //公用成员函数原型声明
    private:
    int num;
    char name[20];
    char gender;
};

//表示Student类作用域中的display函数
void Student::display(){
    cout << "num" << num << '\n'
        << "name" << name << '\n'
        << "gender" << gender << endl;
}
Student stud1,stud2;
```

说明  

1. `::`是作用域限定符，或称作用域运算符，在类外定义成员函数时，必须在函数名前加上类名

2. 如果`::`前面没有类名，或者类名和作用域运算符都没有

​        `::display()` 或者` display()`则表示全局函数（普通函数）

#### 内置成员函数（`inline`）（见内置函数）

类的成员函数也可被指定为内置函数

**概念**

由于类体中函数规模一般较小，调用一个函数的时间开销远远大于执行该函数的时间

为了减小时间开销，如果在'**类体中定义的'成员函数**，且不包括循环等控制结构

Ｃ++系统自动将它们作为'**内置**'函数处理

**使用**

Ｃ++要求对一般的内置函数要用 `inline `关键字声明

但是对类体内部定义的成员函数，可以省略 `inline`，因为这些成员函数已经被隐含地指定为内置函数

也可以自己加上 `inline`

::: warning 注意

对于在类外定义的成员函数

- 在类外定义的函数不是默认内置函数

- 需要自己手动添加 `inline `做显示的声明

- 同样的只有在类外定义的成员函数规模很小而调用频率很高时，才指定为内置函数

:::

**举例**

```cpp
class Student{
    public:
    inline void display();  //声明此成员函数为内置哈是你
    private:
    int num;
    string name;
    char sex;
};

inline void Student::display(){  //在类外定义的函数 display 需要手动添加 inline
    cout<<…………
}
```

​      在普通函数的声明或者定义中做 `inline `声明都可以（有一个就行）

如果在类体外定义 `inline `函数，必须将类定义和成员函数定义都放在同一个头文件中（或者写在同一个源文件中），否则编译时无法置换



#### 成员函数的储存

概念

- '**同一类的不同对象中的数据成员的值一般时不相同的，而不同对象的函数的代码时相同的**，
- **不论调用哪一个函数的代码，其实调用的都是同样内容的代码**'
    - 例证：一个对象所占空间的大小只取决于其数据成员所占的空间，而与成员函数无关（`sizeof(对象)`）

函数的目标代码是储存在对象空间之外的

但是调用不同对象的成员函数执行同一段代码结果却不一样：Ｃ++中专门设立了 `this `指针用来指向不同的对象

-------------------

说明

1. 不论成员函数在类内定义还是在类外定义，成员函数的代码段的储存方式是相同的，都不占有对象的储存空间
2. 不要将成员函数的这种储存方式与 `inline `函数的概念混淆

​        不论是否用 `inline `声明，成员函数的代码段都不占有对象的储存空间

​        `inline `函数只是印象程序的执行效率，而与成员函数是否占有对象的储存空间无关

3. 成员对象的储存方式是从物理的角度而言的，而“对象 `stud1 `的成员函数 `display`”是从逻辑的角度而言的



### 对象成员的引用

  1、通过对象名和成员运算符访问对象中的成员

```cpp
对象名.成员名  //stud1.num  stud1.display()
```

​    应该注意在类外只能调用公有函数，'**在一个类中应至少有一个公用函数成员，作为对外的接口，否则就无法对对象进行任何操作**'

​    举例：

```cpp
#include <iostream>
uisng namespace std;

class Time{
    public:
    int min;
    int hour;
    int sec;
};

int main(){
    Time t1;
    cin >>t1.hour >> t1.min >> t1.sec;
    cout <<t1.hour <<t1.min <<t1.sec;
    return 0;
}
```

  2、通过指向对象的指针访问（与指向结构体的指针相似）

```cpp
class Time{
    public:
    int hour;
    int minute;
};

Time t, *p;     //定义对象t和指针变量p
p = &t;       //使p指向对象t
cout << p->hour;   //输出p指向对象中的成员hour
```

在p指向t的前提下 `p->hour`, `(*p).hour`, `t.hour` 等价

3、通过对象的引用来访问对象中的成员

  为对象定义一个引用；与通过对象名引用一样

```cpp
Time t1;
Time &t2 = t1;  //定义Time类引用t2，并初始化为t1
cout <<t2.hour;  //输出对象t1中的成员hour
```

### 对象名作为函数参数 

在函数中，用对象名作为函数参数时，在函数调用时建立一个新的对象，它是实参对象的拷贝。

'**此时会调用拷贝构造函数，函数结束时调用析构函数！**'

实参把值传给形参，二者分别占有不同的储存空间。

无论形参是否修改都不会影响实参的值。

而且这样的虚实结合要产生实参对象的拷贝，时间和内存开销大

'**因此常用指针作为函数参数，而不用对象名**'





## 用new和delete运算符进行动态分配和撤销储存空间

### new 分配空间

Ｃ++提供了较简单强大的'**运算符**' `new `和 `delete `来取代 `malloc(size)` 和 `free(pointer)` 函数

::: warning 注意

new 和 delete 是'运算符'，不是函数，执行效率高

:::

  2、使用

一般格式为

```cpp
new typename[初值]
```

​    例

```cpp
new int;             
//开辟一个存放整数的储存空间，返回一个指向该存储空间的地址（即指针）

new int(100);          
//开辟存放一个整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址

new char[10];          
//开辟一个存放包含 10 个元素字符数组的空间，返回字符数组首元素的地址

new int[5][10];         
//开辟一个存放而为整型数组（大小为5*4）的空间，返回首元素的地址

float * p = new float(3.14159)  
//开辟一个存放单精度数的空间，并指定该数的初值为3.14159，将返回的该空间的地址赋值给指针变量p
```

::: tip 注意

用 `new `分配数组空间时不能指定初值

如果内存不足等原因无法正常分配空间，则 `new `会返回一个空指针 `NULL `，可以据此判断分配空间是否成功

:::

### delete 撤销储存空间

  1、格式

delete 指针变量；  //对变量

delete [] 指针变量；//对数组

  2、举例

delete p;     //上例中撤销 new 开辟的单精度数的空间

delete [] pt;   //如果把一个开辟的数组空间返回的地址赋值给了pt，在指针变量名前加一对方括号，表示对数组空间的操作

  3、程序举例

​    例，临时开辟一个储存空间以存放一个结构体数据。假设已经声明了一个结构体类型`Student（name，num，sex）`

```cpp
#include <iostream>
using namespace std;

struct Student{
    char name[10];
    int num;
    char sex;

}
int main(){
    Student *p;
    p = new Student;
    p->name = "Wang Fang";
    p->num = 1001;
    p ->sex = 'm';
    cout<<p->name<<'\n'<<p->num<<'\n'<<p->sex<<endl;
    delete p;
    return 0;
}
```

程序说明：

- 本程序没有在主函数中定义结构体变量，而是定义了一个基类型为Student 的指针变量 `p`。
- 用 `new `开辟一段空间以存放一个 `Student `类型的数据，空间大小由系统根据 `Student `自动算出，不必用户指定
- 执行 `new `得到一个指向 `Student `类型的指针赋值给 `p `
- 这样虽然没有定义一个结构体变量，但是可以通过指针变量 `p` 访问该空间
    - 可以认为是对一个'**无名的结构体变量进行操作**'

'**想访问用 new 所开辟的空间，无法通过变量名进行，只能通过指针 p 进行访问**'

### 对象的动态建立与释放

可以用 new 运算符动态建立对象，用 delete 运算符释放这些内存空间

  1、对象的动态建立

​    1、建立

​      如果已经定义了一个 Box 类，可以

new Box;

​      执行此语句时，系统开辟了一段内存空间，并在此内存空间中存放一个 Box 类对象

​      同时调用了该类的构造函数，以使该对象初始化（如果由此功能（默认参数））

​      但是用户无法访问此'无名对象'，new 会返回一个地址，只能通过指针访问，例

Box *pt;    //定义个一个执行Box类对象的指针变量pt

pt = new Box;  //在pt中存放了新建对象的起始地址

​      这样就可以通过指针变量 pt 访问这个新建的对象，如

```cpp
cout << pt->height;
```

​    

​    2、初始化

​      可以在执行 new 时，对新建立的对象进行初始化，如

```cpp
Box *pt = new Box(12,12,12);
```

​      这种写法把 定义指针变量 和 用 new 建立新对象 合并为一句话，并指定初值

​      

​    3、用途

​      主要用于动态的数据结构，如链表

​      访问链表中的节点并不需要对象名，而是上一个节点中存放的下一个节点的地址，从而从上一个节点找到下一个节点，构成链接关系

​    4、错误处理

​      在执行 new 运算时，如果内存不足，无法开辟空间，大多数编译系统会返回一个空指针 NULL 

​      只要检查返回值是否为 0，就可以判断分配内存是否成功 page 275

  2、动态建立对象的释放

​    在不需要由 new 建立的对象时，用 delete 运算符释放，如

delete pt;    //释放pt指向的内存空间

​    这样就撤销了 pt 指向的对象

​    '如果用一个指针变量pt 先后指向了不同的动态对象，应该注意指针变量的当前指向，以免删错对象'

​    在执行 delete 运算符时，在释放内存空间之前，自动调用析构函数，完成善后清理工作