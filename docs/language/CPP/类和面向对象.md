#  类和面向对象

## 对象、面向对象

凡是以类对象为基本构成单位的程序称为基于对象的程序

> 面向对象的程序特点：抽象、封装、继承、多态性

类对象体现了c++的抽象与封装

1. **对象**：万物皆对象（object）

::: tip 对象的两个要素 

- 静态特征:'**属性**'(attribute)

- 动态特征:'**行为（或者功能）**'(behavior)

:::

从外部控制对象：发送一个信息:'**消息**'(message)

- 在一个系统中的多个对象之间通过一定的渠道互相联系

- 要是某一对象实现某一种行为（操作），应向它传送相应的消息

对象是由一组属性和一组行为构成的

C++中，每个对象都是由'**数据**'和'**函数**'构成的

2. **封装与信息隐蔽**

对一个对象进行封装处理，把它的一部分属性和功能对外界隐蔽

把对象的内部实现和外部行为分隔开

::: tip 封装性(encapsulation)

1. 将有关的数据和操作代码封装在一个对象中，形成一个基本单位，各个对象之间相互独立，互不干扰

2. 将对象中的某些部分对外隐蔽，即隐蔽基本细节，只保留少量接口，以便对外联系和接受信息。这种做法被称为信息隐蔽（imofrmation hiding）   //c++中函数名就是对外接口

:::

3. **抽象**

抽象的作用是表示同一类事物的本质

类是对象的抽象，而对象则是类的特例，即类的具体表现形式



4. **继承与重用**

继承机制:若已经建立了一个A类，再建立一个与A基本相同的Ｂ类，不必再从头设计一个新类，只需在A类的基础上增加新的内容

父类/基类

子类/派生类



5. **多态性**

- 多态现象：有几个相似但是不完全相同的对象，在向它们发送同一个消息时，它们的反应各不相同，分别执行不同的操作

- 多态性：由继承而产生的不同的派生类，其对象对同一消息会做出不同的响应。

- 多态性时面向对象程序设计的一个重要特征，能增加程序的灵活性



> *面向对象程序设计的特点
>
> 把数据和有关操作封装成一个对象
>
> 包括两个方面: 
>
> 1. 设计所需的各种类和对象，即决定把那些数据和操作封装在一起
>
> 2. 考虑如何向有关对象发送消息，以完成任务



## 类的声明、定义、引用

类是对象的抽象，对象是类的具体实例

类是对象的'模版'

类是抽象的，不占用内存；而对象是具体的，占用储存空间

### 声明类类型

  与声明结构体类型相似，一般形式为

```cpp
class 类名{
    private:
    私有的数据和成员函数
    public:
    公有的数据和成员函数
};  //有分号结尾！！！！
```

  说明 

- `private`和`public`是成员访问限定符，用来声明各成员的访问属性。
    - 被声明为私有的成员，只能被本类中的成员函数引用，类外的不能调用(友元类除外)

- 还有一种成员限定符' `protected`'，不能被类外访问，但是能被'派生类'成员函数访问
- 声明`private`、`public`、`protected`时没有规定的顺序，访问限定符也可以出现多次（最好一次）
- 如果没有任何声明，默认'`private`'



### 定义对象



  1、先声明类类型，然后在定义对象,eg

```cpp
Student stud1,stud2;  //Student是已经声明过的类类型
```

或者

```cpp
class Student stud1,stud2;  //标准c继承下来的写法，c++种可以像上一种一样不加class更简单
```

  2、在声明类的同时定义对象,eg

```cpp
class Student{
    public:
        void display(){
            cout << "num" << num << '\n'
                << "name" << name << '\n'
                << "gender" << gender << endl;
        }

    private:
        int num;
        char name[20];
        char gender;

}stud1,stud2;   //在这里定义两个类对象，别忘了分号
```

  3、不出现类名，直接定义对象eg：

```cpp
class{
    private:
    	......
    public:
    	......
}stud1,stud2;
```

​    不提倡使用这种方法



### 类的成员函数

性质：  

- 是函数的一种，简称类函数
- 属于类的成员，调用时注意权限
- 对外接口：需要被外界调用的函数应指定为`public`
- 工具函数：为本类中的成员函数调用，是类中其他成员的工具函数，应设置为`private`

#### 在类外定义成员函数

```cpp
class Student{
    public:
    void display();  //公用成员函数原型声明
    private:
    int num;
    char name[20];
    char gender;
};

//表示Student类作用域中的display函数
void Student::display(){
    cout << "num" << num << '\n'
        << "name" << name << '\n'
        << "gender" << gender << endl;
}
Student stud1,stud2;
```

说明  

1. `::`是作用域限定符，或称作用域运算符，在类外定义成员函数时，必须在函数名前加上类名

2. 如果`::`前面没有类名，或者类名和作用域运算符都没有

​        `::display()` 或者` display()`则表示全局函数（普通函数）

#### 内置成员函数（`inline`）（见内置函数）

类的成员函数也可被指定为内置函数

**概念**

由于类体中函数规模一般较小，调用一个函数的时间开销远远大于执行该函数的时间

为了减小时间开销，如果在'**类体中定义的'成员函数**，且不包括循环等控制结构

Ｃ++系统自动将它们作为'**内置**'函数处理

**使用**

Ｃ++要求对一般的内置函数要用 `inline `关键字声明

但是对类体内部定义的成员函数，可以省略 `inline`，因为这些成员函数已经被隐含地指定为内置函数

也可以自己加上 `inline`

::: warning 注意

对于在类外定义的成员函数

- 在类外定义的函数不是默认内置函数

- 需要自己手动添加 `inline `做显示的声明

- 同样的只有在类外定义的成员函数规模很小而调用频率很高时，才指定为内置函数

:::

**举例**

```cpp
class Student{
    public:
    inline void display();  //声明此成员函数为内置哈是你
    private:
    int num;
    string name;
    char sex;
};

inline void Student::display(){  //在类外定义的函数 display 需要手动添加 inline
    cout<<…………
}
```

​      在普通函数的声明或者定义中做 `inline `声明都可以（有一个就行）

如果在类体外定义 `inline `函数，必须将类定义和成员函数定义都放在同一个头文件中（或者写在同一个源文件中），否则编译时无法置换



#### 成员函数的储存

概念

- '**同一类的不同对象中的数据成员的值一般时不相同的，而不同对象的函数的代码时相同的**，
- **不论调用哪一个函数的代码，其实调用的都是同样内容的代码**'
    - 例证：一个对象所占空间的大小只取决于其数据成员所占的空间，而与成员函数无关（`sizeof(对象)`）

函数的目标代码是储存在对象空间之外的

但是调用不同对象的成员函数执行同一段代码结果却不一样：Ｃ++中专门设立了 `this `指针用来指向不同的对象

-------------------

说明

1. 不论成员函数在类内定义还是在类外定义，成员函数的代码段的储存方式是相同的，都不占有对象的储存空间
2. 不要将成员函数的这种储存方式与 `inline `函数的概念混淆

​        不论是否用 `inline `声明，成员函数的代码段都不占有对象的储存空间

​        `inline `函数只是印象程序的执行效率，而与成员函数是否占有对象的储存空间无关

3. 成员对象的储存方式是从物理的角度而言的，而“对象 `stud1 `的成员函数 `display`”是从逻辑的角度而言的



### 对象成员的引用

  1、通过对象名和成员运算符访问对象中的成员

```cpp
对象名.成员名  //stud1.num  stud1.display()
```

​    应该注意在类外只能调用公有函数，'**在一个类中应至少有一个公用函数成员，作为对外的接口，否则就无法对对象进行任何操作**'

​    举例：

```cpp
#include <iostream>
uisng namespace std;

class Time{
    public:
    int min;
    int hour;
    int sec;
};

int main(){
    Time t1;
    cin >>t1.hour >> t1.min >> t1.sec;
    cout <<t1.hour <<t1.min <<t1.sec;
    return 0;
}
```

  2、通过指向对象的指针访问（与指向结构体的指针相似）

```cpp
class Time{
    public:
    int hour;
    int minute;
};

Time t, *p;     //定义对象t和指针变量p
p = &t;       //使p指向对象t
cout << p->hour;   //输出p指向对象中的成员hour
```

在p指向t的前提下 `p->hour`, `(*p).hour`, `t.hour` 等价

3、通过对象的引用来访问对象中的成员

  为对象定义一个引用；与通过对象名引用一样

```cpp
Time t1;
Time &t2 = t1;  //定义Time类引用t2，并初始化为t1
cout <<t2.hour;  //输出对象t1中的成员hour
```

### 对象名作为函数参数 

在函数中，用对象名作为函数参数时，在函数调用时建立一个新的对象，它是实参对象的拷贝。

'**此时会调用拷贝构造函数，函数结束时调用析构函数！**'

实参把值传给形参，二者分别占有不同的储存空间。

无论形参是否修改都不会影响实参的值。

而且这样的虚实结合要产生实参对象的拷贝，时间和内存开销大

'**因此常用指针作为函数参数，而不用对象名**'





## 用new和delete运算符进行动态分配和撤销储存空间

### new 分配空间

Ｃ++提供了较简单强大的'**运算符**' `new `和 `delete `来取代 `malloc(size)` 和 `free(pointer)` 函数

::: warning 注意

new 和 delete 是'运算符'，不是函数，执行效率高

:::

  2、使用

一般格式为

```cpp
new typename[初值]
```

​    例

```cpp
new int;             
//开辟一个存放整数的储存空间，返回一个指向该存储空间的地址（即指针）

new int(100);          
//开辟存放一个整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址

new char[10];          
//开辟一个存放包含 10 个元素字符数组的空间，返回字符数组首元素的地址

new int[5][10];         
//开辟一个存放而为整型数组（大小为5*4）的空间，返回首元素的地址

float * p = new float(3.14159)  
//开辟一个存放单精度数的空间，并指定该数的初值为3.14159，将返回的该空间的地址赋值给指针变量p
```

::: tip 注意

用 `new `分配数组空间时不能指定初值

如果内存不足等原因无法正常分配空间，则 `new `会返回一个空指针 `NULL `，可以据此判断分配空间是否成功

:::

### delete 撤销储存空间

  1、格式

```cpp
delete 指针变量；  //对变量
delete [] 指针变量；//对数组
```

  2、举例

```cpp
delete p;     
//上例中撤销 new 开辟的单精度数的空间
delete [] pt;   
//如果把一个开辟的数组空间返回的地址赋值给了pt，在指针变量名前加一对方括号，表示对数组空间的操作
```

  3、程序举例

例，临时开辟一个储存空间以存放一个结构体数据。假设已经声明了一个结构体类型`Student（name，num，sex）`

```cpp
#include <iostream>
using namespace std;

struct Student{
    char name[10];
    int num;
    char sex;

}
int main(){
    Student *p;
    p = new Student;
    p->name = "Wang Fang";
    p->num = 1001;
    p ->sex = 'm';
    cout<<p->name<<'\n'<<p->num<<'\n'<<p->sex<<endl;
    delete p;
    return 0;
}
```

程序说明：

- 本程序没有在主函数中定义结构体变量，而是定义了一个基类型为Student 的指针变量 `p`。
- 用 `new `开辟一段空间以存放一个 `Student `类型的数据，空间大小由系统根据 `Student `自动算出，不必用户指定
- 执行 `new `得到一个指向 `Student `类型的指针赋值给 `p `
- 这样虽然没有定义一个结构体变量，但是可以通过指针变量 `p` 访问该空间
    - 可以认为是对一个'**无名的结构体变量进行操作**'

'**想访问用 new 所开辟的空间，无法通过变量名进行，只能通过指针 p 进行访问**'









### 对象的动态建立与释放

可以用 `new `运算符动态建立对象，用 `delete `运算符释放这些内存空间

  1、对象的动态建立

​    1、建立

​      如果已经定义了一个 Box 类，可以

```cpp
new Box;
```

​      执行此语句时，系统开辟了一段内存空间，并在此内存空间中存放一个 Box 类对象

​      同时调用了该类的构造函数，以使该对象初始化（如果由此功能（默认参数））

​      但是用户无法访问此'无名对象'，new 会返回一个地址，只能通过指针访问，例

```cpp
Box *pt;    //定义个一个执行Box类对象的指针变量pt
pt = new Box;  //在pt中存放了新建对象的起始地址
```

​      这样就可以通过指针变量 pt 访问这个新建的对象，如

```cpp
cout << pt->height;
```

​    

​    2、初始化

​      可以在执行 new 时，对新建立的对象进行初始化，如

```cpp
Box *pt = new Box(12,12,12);
```

​      这种写法把 定义指针变量 和 用 new 建立新对象 合并为一句话，并指定初值

​      

​    3、用途

​      主要用于动态的数据结构，如链表

​      访问链表中的节点并不需要对象名，而是上一个节点中存放的下一个节点的地址，从而从上一个节点找到下一个节点，构成链接关系

​    4、错误处理

​      在执行 new 运算时，如果内存不足，无法开辟空间，大多数编译系统会返回一个空指针 NULL 

​      只要检查返回值是否为 0，就可以判断分配内存是否成功

  2、动态建立对象的释放

​    在不需要由 `new `建立的对象时，用 `delete `运算符释放，如

```cpp
delete pt;    //释放pt指向的内存空间
```

​    这样就撤销了 pt 指向的对象

​    '如果用一个指针变量pt 先后指向了不同的动态对象，应该注意指针变量的当前指向，以免删错对象'

​    在执行 delete 运算符时，在释放内存空间之前，自动调用析构函数，完成善后清理工作





## 对象的初始化

::: warning

不能在类的声明中对数据成员初始化，因为类不是一个实体，而是一种'**抽象类型，不占用储存空间**'

:::

如果一个类中所有的成员都是公用的，可以在'**定义对象**'时，对数据成员进行初始化

但是如果类中有`private`或者`protected`的数据成员，就不能用这种方式初始化

### 构造函数

用构造函数实现数据成员的初始化

  

#### 构造函数(constructor)

是一种特殊的成员函数，不需要用户调用，在建立对象的时候自动运行

构造函数的名字必须与类名同名，不具有任何类型，不返回任何值，eg

```cpp
class Time {
    public:
    Time(){        
        //定义构造成员函数，函数名与类名相同
        hour = 0;   
        //利用构造函数对对象中的数据成员赋值
        minute = 0;
        sec = 0;
    }
    void set_time();   //声明成员函数
    void show_time();  //声明成员函数
    private:
    int hour;
    int minute;
    int sec;
};  //声明类对象大括号结尾的分号！
```

说明  

- 与在声明类时对数据成员赋值不同，赋值语句是写在构造函数的函数体中的，只用在调用构造函数的时候才执行这些赋值语句
- 赋值步骤:先建立对象t1（这里略写类），在执行构造函数的过程中对t1中的数据成员赋值
- 也可以在类的定义内仅声明构造函数，在类的定义外定义构造函数，eg

```cpp
……
Time();    
//在类的定义内仅有声明
……
    
//在类的定义外构造成员函数，要加上类名Time和域限定符"::"
Time::Time(){
    hour = 0;
    minute = 0;
    sec = 0;
}
```

说明：

- 在建立类对象的时候自动调用构造函数。建立对象的时候系统为该对象分配储存单元，此时执行构造函数，把初值送到储存单元中。每建立一个对象就调用一次构造函数
- 构造函数呢没有返回值，没有类型，总用仅为初始化对象
- 不需要也不能被用户调用,在定义对象的时候由系统自动执行，只能执行一次，'构造函数一般声明为public'
- 可以用一个类对象初始化另一个类对象

```cpp
Time t2=t1；  //建立对象t2，并用t1初始化t2，此时不调用t2.Time()
```



- 如果用户没有定义构造函数，系统会自动生成一个构造函数，函数体是空的，没有任何操作

​      

​      

#### 带参数的构造函数

上面的方法使得每一个对象的初值相同，但是无法用于对不同的对象赋予不同的初值

所以可以采用'**带参数的构造函数**'，在调用不同对象的构造函数时，从外面将不同的数据传递给构造函数，以实现不同时初始化，函数首部一般为：

```cpp
构造函数名(类型1 形参1，类型2 形参2，…)
```

由于用户无法调用构造函数，所以在定义对象的时候给出实参：

```cpp
类名 对象名(实参1，实参2，……)；
```

例：俩长方体，用俩类求体积

```cpp
class Box{
    public:
    Box(int,int,int);  
    //用函数原型声明带参数的构造函数
    int volume();
    private:
    int height;
    int width;
    int length;
};//分号！！！！！！

Box::Box(int h ,int w,int l){
    //在类外定义带参的构造函数
    height = h;
    width = w;
    length = l;
}

int Box::volume(){
    return(height*width*length); 
    //定义求体积函数
}

int main(){
    //在定义对象的时候给出实参，初始化对象
    Box box1(12,34,13);
    cout <<…………<< box1.volume()<<……  
        //建立（定义）对象box1，并指定box1的长宽高
        //在定义对象的时候给出实参，初始化对象
        Box box2(394,223,34);
    cout <<…………<< box2.volume()<<……  
        //建立对象box2，并指定box2的长宽高
        return 0;
}
```

说明:

- 带参构造函数中的形参对应的实参是在建立对象时给定的。
- 在建立对象的同时指定数据成员的初值

​        

#### 用参数初始化表对数据成员初始化

在函数首部实现对数据成员的初始化

一般形式如

> **方括号内的可有可无**

```cpp
类名::构造函数名([参数表])[:成员函数初始化表]
{
  [构造函数体]
}
```

​    上一例中，可以改为：

```cpp
Box::Box(int h,int w,int l):height(h),width(w),length(l){}
```

- 用形参`h`的值初始化数据成员`height`……
- 空的花括号

::: warning 对于数组

**数据成员是数组不能在参数初始化表中对其初始化**，应当在构造函数的函数体中用语句对其初始化。

:::



#### 构造函数重载

概念

一个类中可以定义多个构造函数，以为对象提供不同的初始化方法选择

这些构造函数具有相同的名字，而**参数的个数或者类型不同**

这被称为构造函数的'重载'

使用 

1. 在建立对象时不必给出实参的构造函数，为默认构造函数

无参的构造函数属于默认构造函数

一个类只能有一个默认的构造函数

如果用户没有定义构造函数，系统自动提供的默认构造函数函数体是空的，不初始化

如果要在创建对象时就有初值，就必须自己定义构造函数

2. 如果在建立对象时用的是无参的构造函数

> 注意此时定义对象的写法：

```cpp
Box box1;  //正确建立对象并调用了默认构造函数
Box box1(); //错误，是声明一个普通函数返回值为 Box 类型
```

**构造函数不能被用户显式调用**

3. 一个类中可以有多个构造函数，但是建立一个对象时只能调用其中一个构造函数

​      

#### 默认参数的构造函数

​    **构造函数中参数的值既可以通过实参传递，也可以指定为某些默认值**

​    （有默认参数的普通函数）在声明构造函数时指定默认参数

```cpp
#include <iostream>
using namespace std;
class Box{
    public:
    Box(int h = 10,int w = 10,int len = 10);
    //Box(int = 10,int = 10,int = 10);   //形参名可以省略
    int volum();
    private:
    int height;
    int width;
    int length;
};

Box::Box(int h,int w,int len){
    height = h;
    width = w;
    length = len;
}

int Box::volume(){
    return(height*width*length);
}

int main(){
    Box box1;       //没有给实参，形参均取默认值
    Box box2(15);     //只给一个实参，w和len去默认值
    Box box3(13,45);   //只给两个实参，
    Box box4(23,44,55);  //给三个实参
    return 0;
}
```

说明：

1、在什么地方指定构造函数的默认参数？

'应该在声明构造函数时指定默认值，而不是在定义构造函数时指定默认值'

2、声明构造函数时'**形参名可以省略**'，即

```cpp
Box(int = 10,int = 10,int = 10);
```

3、**应该避免同时出现定义了 无参的构造函数 和 全部参数都指定了默认值 的构造函数**

以避免出现歧义性为原则

::: tip

构造函数全部参数指定了默认值，在定义对象时也可以不给出实参

此时也属于默认构造函数，如果还定义了无参的构造函数，就会出现歧义

**一个类只能有一个默认构造函数**

**可以不用参数而调用的构造函数只能有一个**

:::



4、在一个类中定义了全部时默认参数的构造函数之后，不能再定义重载构造函数

如果构造函数中的参数并非完全默认值，需要具体分析，**以是否出现歧义为标准**

例1,

有如下声明：

Box(int = 11,int = 11,int = 11);

Box();

Box(int,int);

有如下定义？

Box box1;

Box box2(11,22);

例2，有如下声明：

Box(int,int = 10,int = 11);

Box();

Box(int,int);

有如下定义？

Box box1;

Box box2(11);

Box box3(11,22);



## 析构函数（destructor）

- 析构函数也是一个特殊的成员函数，作用与构造函数相反
    - 在类名前加一个'`~`'位取反运算符
    - 当对象的生命周期结束时，自动执行析构函数
        - 在一个函数中定义了一个对象（局部），当函数被调用结束时，对象应该被释放，在对象释放前自动执行析构函数
        - '**静态**'(static)  局部对象在函数调用结束时对象并不释放，因此不调用析构函数，只有在`main`函数结束或者调用  `exit()` 函数结束时，才调用 `static`局部对象的析构函数
        - 如果定义了一个全局对象，则在函数的流程离开其作用域时（例如`main`函数结束或者调用`exit`函数），调用该全局对象的析构函数
        - 如果用 `new`运算符动态的建立了一个对象，应用 `delete`运算符释放该对象时，先调用该对象的析构函数

- '**析构函数作用并不是删除对象，而是在撤销对象占用内存之前完成一些清理工作**'

还可以来执行'**在最后一次使用对象之后的任何操作**'

析构函数不返回任何值，没有函数类型。没有函数参数，所以'**不能被重载**'

一个类可以有多个构造函数，但是只能有一个析构函数

> 如果用户没有在声明类的时候定义析构函数，编译系统自动生成一个无任何操作的析构函数

- 析构函数举例：

```cpp
#include <string>
#include <iostream>
using namespace std;
class Student{                   
    //声明类，在main之前，作用域全局
    public:
    Student(int n,string nam,char s){     //定义有参构造函数
        num = n;
        name = nam;
        sex = s;
        cout << "Constructor called"<< endl;
    }
    ~Student(){                //定义析构函数
        cout << "Destructor called"<<endl;
    }
    void display(){              //定义成员函数
        cout << "num" << num << '\n'
            <<"name" << name <<'\n'
            <<"sex:" << sex << endl;
    }
    private:
    int num;
    char name[10];
    char sex;
};

int main(){
    Student stud1(10010,"Gan",'m');  //定义对象stud1
    stud1.display();         //输出stud1数据
    Student stud1(10020,"qin",'f');
    stud2.diaplay();
    return 0;
}
```



::: warning 调用构造函数和析构函数的顺序

**先构造的后析构，后构造的先析构**，

相当于一个栈，先进后出

:::

::: tip 什么时候调用析构函数和构造函数？

1、在全局范围定义的对象

构造函数：

在本文件模块中所有函数（包括main）之前调用

如果一个程序包含多个文件，每个都有全局对象，则顺序不确定

析构函数

在 main 函数执行完毕 或者 调用 exit() 函数时

2、局部自动对象（例如在函数中定义的对象）

构造函数：

建立对象时调用

如果函数调用多次，每次都要调用

析构函数

函数调用结束时，对象释放前调用析构函数

3、在函数中定义的'**静态**' static 局部对象

构造函数：

只在程序第一次调用时调用构造函数

析构函数：

静态局部对象在函数调用结束时不释放，

因此在 main 函数结束或者调用 exit() 时对象释放时调用析构函数

:::



## 对象的赋值与复制

### 对象的赋值

1、概念

如果一个类定义了两个或多个对象，则这些同类对象之间可以相互赋值

通过成员复制完成

对象的赋值只对其中的数据成员赋值，不对成员函数赋值

'**类中的数据成员不能包括动态分配的数据，否则在赋值时会出现严重后果**'

对象之间的赋值通过赋值运算符 `=` 进行

（本来 `=` 只能对单个变量赋值，这里通过运算符重载扩展了使用）

2、形式

```cpp
对象名1 = 对象名2;
```

对象名1和对象名2必须属于同一个类，如

```cpp
Student stud1,stud2;  //定义两个同类的对象
stud2 = stud1;     //将 stud1 赋给 stud2
```

  3、举例

```cpp
#include <iostream>
using namespace std;
class Box{
  public:
Box(int = 10,int = 10,int = 10);  //声明有默认参数的构造函数
    int volume();
    private:
    int height;
    int width;
    int length;
};

Box::Box(int h,int w,int len){     
    //定义构造函数
    height = h;
    width = w;
    length = len;
}

int Box::volume(){           
    //定义体积函数
    return(height*width*length);    //返回体积
}

int main(){
    Box box1(15,23,44),box2;      //定义两个对象
    cout << "The volume of box1 is"<<box1.volume()<<endl;
    box2 = box1;            //将 box1 的值赋给 box2
    cout << "The volume of box2 is"<<box2.volume()<<endl;
    return 0;
}
```



### 对象的复制

用一个已有的对象快速地复制出多个完全相同的对象

1. 一般形式为

```cpp
类名 对象2(对象1);
```

用` 对象1` 复制出 `对象2` ，例

```cpp
Box box2(box1);  //用已有的 box1 复制出 box2
```

2. 还可以用赋值号代替括号

一般形式为

```cpp
类名 对象2 = 对象1;
```

例，

```cpp
Box box2 = box1;
```

还可以在一个语句中对多个对象进行复制，如

```cpp
Box box2 = box1，box3 = box2;  //按 box1 复制出 box2 和 box3
```

#### 复制构造函数

1. 概念

对象复制与对象定义的方式相似，但是括号中的参数不是一般变量而是对象名

在建立对象时调用一个特殊构造函数————'**复制构造函数'(copy constructor)**

```cpp
Box::Box(const Box& b){
    height = b.height;
    width = b.width;
    length = b.length;
}
```

复制构造函数只有一个参数，是'**本类的对象**'

采用对象的引用形式，一般约定用 `const `声明，防止调用时不慎改变实参

2. 调用

由于参数是对象，编译系统就调用复制构造函数（构造函数重载？）而不会调用其他构造函数

如果用户没有自定义复制构造函数

系统默认的复制构造函数只是简单的复制类中的每个数据成员

​        

### 有关比较

#### 对象的复制与赋值

​    对象的赋值是对一个已经存在的对象赋值，必须先定义被赋值的对象

​    对象的复制是复制出一个新的对象，与原对象完全相同

#### 普通构造函数和复制构造函数

1. 形式上

普通构造函数：

```cpp
类名(形参列表);
```

复制构造函数

```cpp
类名(类名 &对象名);
```

2. 建立对象时实参类型不同

系统会根据实参的类型决定调用普通构造函数还是复制构造函数

```cpp
Box box1(11,22,33);  //实参是整数，调用普通构造函数
Box box2(box1);    //实参是对象名，调用复制构造函数
```

3. 使用方式不同

- 普通构造函数

在程序中建立对象时被调用

-------------------

- 复制构造函数

在用已有的对象复制一个新对象时被调用：

1、程序中需要建立一个新对象，并用一个同类的对象对它进行初始化

2、当函数的参数为类的对象时

在调用函数时需要将实参对象完整地传递给形参，需要建立一个实参的的拷贝

这时需要调用复制构造函数实现

3、函数的返回值是类的对象

在函数调用完毕将返回值带回函数调用处时，需要将函数中的对象复制一个临时对象传给函数调用处

举例

```cpp
Box f(){         //函数 f 的类型为 Box 类类型
    Box box1(11,22,33);
    return box1;     //返回值是 Box 类的对象
}
int main(){
    Box box2;       //定义 Box 类的对象 box2
    box2 = f();      
    //调用 f 函数，返回 Box 类的临时对象，并将它赋值给 box2
    return 0;
}
```

说明；

由于 `box1`是在函数 `f` 中定义的，调用结束时，`box1`的生命周期结束

因此不是将 `box1`带回了主函数，而是在函数 `f` 结束前，调用 `Box`类中的复制构造函数

复制 `box1`得到一个临时对象，再赋值给 `box2`



## 对象数组

数组不仅可以由简单变量组成，也可以由类对象组成

'**对象数组的每一个元素都是同类的对象**'

1.定义

​    例如，定义一个学生类的对象数组，每一个数组元素就是一个“学生类”对象

```CPP
Student stud[50];  //假设已声明了 Student 类，定义 stud 数组，有五十个元素
```

2. 初始化

构建对象数组一定要有默认构造函数（或者全为默认参数）

在建立对象数组时，会调用构造函数，如果有50个元素，就要调用50次

在需要时可以在定义数组时提供实参以实现初始化

- 如果构造函数只有一个参数，在定义数组时可以直接在等号后面的花括号内提供实参，例

```cpp
Student stud[3] = {23，42，56}；  //三个实参分别传递给3个数组元素的构造函数
```

​	编译系统只为每个元素对象的构造函数传递一个实参，'**提供的的实参个数不能超过数组元素个数**'

- 如果构造函数有多个参数
    - 不能在定义数组时直接提供所有实参，容易产生歧义（如果采用上例方法，则是提供给三个元素的第一个实参）
    - 应该在花括号中分别写出**构造函数名**并在括号内指定实参，例(三个参数分别为学号，年龄，成绩)

```cpp
Student Stud[3]={     //定义对象数组
    Student(1002,12,34),  //调用第一个元素的构造函数，向它提供三个实参，用逗号隔开
    Student(1003,34,66),
    Student(1004,34,23)  
};             //是一个语句，注意末尾有分号
```

3. 应用举例





## 对象与指针

### 指向对象的指针（类比结构体指针）

在建立对象时，编译系统会为每一个对象分配一定的储存空间，以存放数据成员

**对象空间的起始地址就是对象的指针**

  1、定义指向对象的指针,若有一个类如下：

```cpp
class Time{
    public:
    int hour;
    int minute;
    int sec;
    void ge_time();  //在类中声明成员函数
};            //类定义结尾的分号！

void Time::get_time(){  //在类外定义成员函数
    cout<< hour <<":"<<minute<<":"<<sec<<endl;
}
```

​    在此基础上定义指向对象的指针变量

```cpp
Time * pt;  //定义pt为指向Time类对象的指针变量
Time t1;   //定义ti为Time类对象
pt = &t1;   //将t1的起始地址赋值给pt
```

定义类对象的指针的一般形式为：

```cpp
类名 * 指针对象名;
```

  2、通过指针对象访问对象和对象的成员

```cpp
*pt;        //pt所指向的对象t1
(*pt).hour     //pt所指向对象中的hour成员，即t1.hour
pt ->hour     //pt所指向对象中的hour成员，即t1.hour
(*pt).get_time()  //调用pt所指向对象中的get_time函数，即t1.get_time
pt ->get_time()  //调用pt所指向对象中的get_time函数，即t1.get_time
```



### 指向对象成员的指针

指向对象的指针变量：存放对象的起始地址的指针变量

指向对象成员的指针变量：存放对象成员地址的指针变量

#### 指向对象数据成员的指针

定义指向对象数据成员的指针变量的方法和定义指向普通变量的指针变量方法相同，如

```cpp
int *p1;	
typename *pointername;  //定义指向对象数据成员的指针变量的一般形式
```

如果`Time`类的数据成员`hour`为`public`，

可以在类外通过指向对象数据成员的指针变量访问对象的数据成员`hour`

```cpp
p1 = &t1.hour;    //将对象t1的数据成员hour的地址赋给p1，p1指向t1.hour
cout << *p1 <<endl;  //输出t1.hour
```

::: warning 注意

不能用在类外的指针指向私有的数据类型，因为在类外无法访问！

:::

#### 指向对象成员函数的指针

注意与指向普通函数的指针变量的区别

​    

::: tip 复习：指向普通函数的指针：

```cpp
typename (*指针变量名)(参数表列);//如
void (*p)();          //p是指向void型函数的指针变量
```

  可以通过使它指向一个函数，并通过指针变量调用函数

```cpp
p = fun;   //将fun函数的入口地址赋给指针变量p，p就指向函数fun
(*p)();   //调用fun函数
```

:::

1、概念   

指向'**对象成员函数**'的指针要复杂一些，编译系统要求指针变量的类型与赋值号右侧的函数类型相匹配：

- 函数的参数的类型和参数个数
- 函数返回值的类型
- 所属的类

如果直接使上例中的`p`指向一个成员函数，`p`与类无关，**不能在类外直接用成员函数名作为函数入口地址去调用成员函数**

2、定义与初始化

定义指向成员函数的指针变量，使其指向一个共用成员函数

```cpp
void(Time:: *p2)();     //定义p2为指向Time类中公用成员函数的指针变量
p2 = &Time::get_time;    //使指针变量指向一个公用成员函数
```

一般形式为：

```cpp
typename(类名:: *指针变量名)(参数表列);  //注意，第一个括号不能省略，否则就是返回值为“typename”类型的指针函数
指针变量名 = &类名::成员函数名;  //把公用成员函数的入口地址赋给一个指向公用成员函数的指针变量即可
```

::: warning 注意  

- 成员函数入口地址的写法为`&类名::成员函数名`，不能写成 `p2 = &t1.get_time`; 
    - 因为`t1`是对象名而不是类名（成员函数不是存放在对象空间中的，而是存放在对象外）

- 定义指向成员函数的指针变量和初始化可以写一行：

```cpp
void(Time:: *p3)() = &Time::get_time;  //定义指针变量并初始化
```

- 可以不写&，和指向普通函数的指针的赋值一样

```cpp
p = Time::get_time;
```

:::



### this 指针

每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为 `this`

`this`指针是'指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址'

用来解决不同对象调用同一个函数的目标代码时，保证引用的所指定对象的成员

例如，当调用成员函数 `a.volume` 时，编译系统就把对象`a`的起始地址赋给 `this` 指针，在成员函数引用数据成员时，就按照 `this` 的指向找到对象`a`的数据成员 

`this` 指针是隐式使用的，它是作为参数被传递给成员函数的

综上所述，所谓“调用对象a的成员函数f”，实际上是在调用成员函数f时使 this 指针指向对象a，从而访问对象a的成员



## 类模板

与函数模板类似

有多个类，功能是相同的，仅仅是数据类型不同

Ｃ++提供模板功能，提供解决这类问题的途径

### 声明

声明通用类模板

```cpp
template <class 类型参数名>
    class 类名{类体};
```

例：

```cpp
template <class numtype>
    class Compare{
        public:
        Compare(numtype a,numtype b){
            x = a;
            y = b;
        }
        numtype max(){
            return((x>y)?x:y;)
        }
        numtype min(){
            return((x<y)?x:y;)
        }
        private:
        numtype x,y;
};
```

注意：

1. 声明类模板前面加一行

```cpp
template <class 类型参数名>
```

`template`是声明类模板的关键字

在 `template`后面的尖括号内的内容为模板的参数表

关键字 `class` 表示后面的是类型参数

- 本例中 `numtype` 就是一个类型参数名，这个名字是任意选取的，合法的标识符
- 并不是实际存在的类型名，只是一个虚拟类型参数名
- 在这之后将被一个实际的类型名取代;

---------------

2. 在建立类对象时，如果将实际类型指定为 `int` 型，编译系统就会用 `int` 取代所有 `numtype`

这样就能实现'**一类多用**'

由于类模板包含类型参数，因此又被称为'**参数化的类**'

类是对象的抽象，对象是类的实例

'**类模板是类的抽象，类是类模板的实例**'

​    

### 使用

1、一般形式

```cpp
类模板名 <实际类型名> 对象名(参数表);
```

不能直接用 类模板名，因为不是一个具体的类

2、举例

```cpp
Compare <int> cmp(4,7);
```

说明：

- Compare是类模板名，在之后的尖括号内指定实际的类型名
- 在编译时，系统用 int 替换类模板中的类型参数 numtype
- 这样就把类模板具体化（实例化）

​        

### 在类模板外定义成员函数

不能使用一般定义类成员函数的形式

而应该写成类模板，例

```cpp
template <class numtype>
    numtype Compare<numtype>::max(){
        return(x>y?x:y);
    }
```

说明：

第一行表示类模板

第二行左边的 `numtype`是虚拟类型名，

后面的 `Compare<numtype>` 是一个整体，是带参的类

表示所定义的 max 函数时在类 `Compare<numtype>` 的作用域内的，

在定义对象时，用户指定实际类型的时候，编译器将类模板中的虚拟类型名 `numtype` 替换为实际类型

这时 `Compare<numtype>` 就相当于一个实际的类，

  

### 总结

1、先写出一个实际的类

2、将此类中准备改变的类型名改成一个自定的虚拟类型名

3、在类的声明前面加入一行：

```cpp
template <class 虚拟类型参数>
```

4、用类模板定义对象时，用以下形式

```cpp
类模板名<实际类型名>对象名;
类模板名<实际类型名>对象名(实参表);
```

5、如果在类模板外定义成员，应该写成类模板形式

```cpp
template<class 虚拟类型函数>
    函数类型 类模板名<虚拟类型参数>::成员函数名(函数形参表){
        ………
    }
```

6、类模板的类型参数可以有一个或多个，每个类型前面都必须加 `class`，如：

```cpp
template <class T1,class T2>
    class A{………………};
```

定义时分别加入实际的类型名

```cpp
A<int,double>obj;
```

7、使用类模板要注意其作用域，只能在其有效作用域内用它定义对象

如果类模板是在文件A开头定义的，则A文件范围为有效作用域，但是在B文件中不能用类模板定义对象

8、类模板可以有层次，一个类模板可以作为基类，派生出派生模板类