# 指针
指针是一个值为内存地址的变量(或者数据对象) 

> 内存地址一般用16进制表示

```cpp
地址 -> 内容
```

- 直接存取/直接访问:使用变量名（效率最高）

- 间接存取

变量的指针就是变量的地址；一个变量的地址称为该变量的指针

**指针变量**：用来存放变量地址的变量是**指针变量**

**指针的大小与语言、类型、编译器无关，与硬件有关**：

- 32位系统：
- 64位系统：



### &：取地址运算符
```cpp
i_pointer = &i //将i的地址放入i_pointer中，&i是变量i储存单元的 起始地址
```

`*`：指针运算符（间接访问运算符）表示指向
	`i_ptr`是一个指针变量，`*i_ptr`表示 `i_ptr` 所指向的变量
	`i = 3`；等价于`*i_ptr = 3;`  将3赋给i_ptr所指向的变量
	

### 声明及初始化指针变量

**声明指针**

​		

```cpp
数据类型 * 指针变量名 //该指针变量指向的变量的类型，基类型
typename * pointername
```

例	

```cpp
in * ptr_num;
char * ptr_name;
float * money_ptr;
double * p_price;
```

> 变量名前加一个 `*` 表示该变量是指针变量，指针变量的变量名中不含 `*`

**初始化指针变量**

```cpp
i_ptr = &i;
```

**只能用 & 对指针变量赋值**

::: warning 注意

1. 定义指针变量时必须声明其基类型（为了判断从内存中取多少数据大小）

2. 不能用一个具体的数给指针变量赋值，可以将一个已经定义的变量的地址作为指针变量的初值

```cpp
int i;
int *p = &i;
```

3. 一个指针变量只能指向同一个类型的变量
4. 在说明变量类型的时候，不能一般的说 “a是一个指针变量” ，而是 “a是指向整型数据的指针变量”（或者int*型变量）

:::



## 引用指针变量
指针使用示例

```cpp
#include <iostream>
using namespace std;
int main(){
	/*double num = 1024.5;
//声明一个指针，指向num变量
	double* ptr_num = &num;
	cout << "ptr_num的值：" << ptr_num << endl;
	cout << "ptr_num指向空间的值是：" << *ptr_num << endl;
	*/
	char ch = 'a';
	cha * ptr_ch = &ch;
	//cha *在标准c中是定义字符串？？
	//思考：打印的结果是地址？还是ch的值？
	//有问题，char型指针在c/c++中是字符串了？？
	//cout << ptr_ch << endl;
	cout << (void *)ptr_ch << '\t' << *ptr_ch<<endl;//强制转换
	//void *任意类型的指针，（总之打印出来，不管什么类型）
	return 0;
}
```

对于取地址运算符&和指针运算符*的说明：

```cpp
int * ptr_1;
ptr_1 = &a;
& * ptr_1 //是什么？ 
```

1. `&` 与`*`的优先级相同，从右往左结合，即`&(*ptr_1)`等价于`&a` ，即`a`的地址

2. ` *&a` 等价于`a `



## 空指针（null pointer）

空指针不指向任何对象，在试图使用一个指针之前可以检查是否为空

用法：

```cpp
int * ptr1 = nullptr;
int * ptr2 = 0;  //能这样用吗？？？

#include <cstdlib>
int * ptr3 = NULL
```

以上三种等价

::: danger 野指针
	指针最危险的是没有指向任何对象，为了避免野指针出现，可以将指针初始化为0（nullptr）

:::



## `void *` 指针
​	一种特殊的指针类型，可以存放任意对象的地址

​	不指向任何类型的数据，理解为指向空类型，或者不指向确定类型

::: warning 注意	

1、void* 指针存放一个内存地址，地址指向的内容是什么类型不能确定，由此

```cpp
void* ptr1 = &num; *ptr1 = 123; //是错误的！
```

2、一般用来和其他的指针比较；作为函数的输入和输出；赋值给另一个 `void*` 指针

```cpp
char *p = "string";
cout<<(void*)p;  //输出字符串的地址
```

3、可以将非void指针赋值给void指针，但是不能把void指针赋值给非void指针（需要强制转换），例：

```cpp
char* p2; 
void* p3; 
p2 = (char*)p3;
```

:::			

​				

## `const` 指针
可以指定指针变量是一个常量，或者指定指针变量指向的对象是一个常量
### 指向常量的指针变量
​	1、定义：

```cpp
const typename * 指针变量名;
```

​	经过此定义后，不允许通过指针变量改变它指向的变量的值，例

```cpp
int a = 12,b = 15;
const int *p = &a;  //定义了p为指向整型变量 a 的 const 指针变量
*p = 15;            //试图通过p改变它指向的对象a的值，??非法     
```

2、说明

​	虽然不能通过 p 来改变 a 的值，但是'指针变量p的值（即p的指向）可以改变'

```cpp
p = &b;             //合法
```

​	定义了：(const int *)的指针变量之后，仍然可以通过直接赋值的方法改变 a 的值

```cpp
a = 15；
```

​	用指向常量的指针变量只是'限制了通过指针变量改变它指向的对象的值'
​	

#### 指向常变量的指针变量

如果想保证指向的对象的值不变，应该定义为常量：

```cpp
const int a = 12;
```

此时 `p` 就成了 **指向常变量的指针变量**，此时用用直接访问或者间接访问的方式都无法改变 `a` 的值

**说明**	

- 如果一个变量已被声明为常变量，只能用指向常变量的指针变量指向它，而'不能'用一般的（非 `const`）类型的指针变量指向
- 指向常变量的指针变量还能指向普通变量（指向常量对指针变量）（非 `const`）
    - 此时不能通过此指针变量改变该变量的值，但是能够直接对变量赋值
    - 定义指向常变量对指针变量p并使它指向c1，并不是说c1也声明为常变量，而只是'用指针变量访问c1期间，c1具有常变量对特征'，其值不能改变
- 如果函数的形参是指向普通变量（非 `const`）的指针变量，实参只能用指向普通变量的指针，这样可通过指针改变指向变量的值



::: tip 表.用指针变量作形参时形参和实参的对应关系

| 形参                      | 实参                | 是否合法 | 改变指针所指向的变量的值 |
| ------------------------- | ------------------- | -------- | ------------------------ |
| 指向非 const 型变量的指针 | 非 const 变量的地址 | 合法     | 可以                     |
| 指向非 const 型变量的指针 | const 变量的地址    | 非法     | 非法                     |
| 指向 const 型变量的指针   | const 变量的地址    | 合法     | 不可以                   |
| 指向 const 型变量的指针   | 非 const 变量的地址 | 合法     | 不可以                   |

:::



**用途**

指向常量的指针变量常用作函数的形参，以防止指针形参所指对象的值改变影响实参

举例，在函数中改变指针形参所指对象的值

```cpp
#include <iostream>
using namespace std;
void fun(int *p){    //形参是指向整型变量的指针变量
	*p = 5 * (*p);   //使p所指的变量为原值的5倍
}
int main(){
	int a = 10;
	fun(&a);         //用 a 的地址作为实参
	cout << a <<" "<<endl;
	return 0;
}
```

运行结果：
50

在以上程序中，如果不想在调用函数时改变指针形参所指对象的值，可以将形参改为指向常量的指针变量，

```cpp
void fun(const int *p){   //形参是指向常量的指针变量
    *p = 5 * (*p);        //错误
}
```

不允许通过指针变量p的值改变 *p 的值，而只能使用 *p 的值



### 常指针
​	指定指针变量的值是常量。即指针变量的指向不能改变

1. 定义

```cpp
typename * const 指针变量名;
```

说明：	

- 这种指针变量称为'常指针变量'，简称'常指针'，即指针值不能改变
- 必须在定义时初始化，指定其指向
- 指针变量的指向不能改变，但是指向的变量的值可以改变
- 注意 `const` 和 `*` 的位置。`const` 在 `*` 之后 

举例

```cpp
int a = 4;
int b = 6;
int * const p2 = &a;   //定义常指针同时初始化指向a
*p = 12;               //使指向的变量的值改变
```

### 指向常量的常指针
即 **指针变量指向一个固定的对象，且不能通过指针变量改变该对象的值**（以上两种合在一起）

1. 定义

```cpp
const typename * const 指针变量名;
```

2. 举例

```cpp
int a = 10;
int b = 20;
const int * const pt = &a;
/*
pt = &b;   //错误，试图改变指针的指向
*pt = 30;  //错误，试图通过指针改变所指对象的值
*/
a = 3;     //仍然可以对 a 直接赋值

// '如果要完全禁止改变a的值，可以将a定义为常变量'
const int a = 10；
```



## 指针小结

### 有关指针的数据类型小结

| 变量定义               | 类型表示          | 含义                                                         |
| ---------------------- | ----------------- | ------------------------------------------------------------ |
| `int i; `              | int               | 定义整型变量 i                                               |
| `int *p;`              | int*              | 定义 p 为指向整型数据的指针变量                              |
| `int a[5];`            | int[5]            | 定义整型数组 a，有五个元素                                   |
| `int *p[4];`           | int*[4]           | 定义指针数组 p，由四个指向整型数据的指针元素组成             |
| `int (*p)[4];`         | int(*)[4]         | p 为指向包含四个元素的一维数组的指针变量                     |
| `int f();`             | int()             | f 为返回值类型为 int 的函数                                  |
| `int *p();`            | int*()            | p 为返回一个指针的函数，该指针指向整型数据                   |
| `int (*p)();`          | int(*)()          | p 为指向函数的指针，该函数返回一个整型值                     |
| `int **p;`             | int**             | p 是一个指针变量，它指向一个指向整型数据的指针变量           |
| `int *const p;`        | int *const        | p 是常指针，其值是固定的，即其指向不能变                     |
| `const int *p;`        | const int*        | p 是指向常量的指针变量，不能通过 p 改变其指向的对象的值      |
| `const int * const p;` | const int * const | p 是指向常量的常指针，其指向不能改变，且不能通过 p 改变其指向的变量的值 |
| `void *p;`             | void              | p 是一个指针变量，基类型为 void，不指向具体的对象            |



### 指针运算小结

1. 指针变量加/减一个整数
      	p++、p--、p+i、p-i、p-=i等

      ​	一个指针变量加/减一个整数是将该指针变量的原值（一个地址）和它指向的变量所占用的内存单元字节数相加或相减

      ​	如 `p+ i` 代表 `p + i*d`

2. 指针变量赋值

    将一个变量地址赋值给一个指针变量

    ```cpp
    p = &a;       //将变量 a的地址赋给 p
    p = arry;     //将数组 array 首元素的地址赋给 p
    p = &arry[i]; //将数组 array 第 i 个元素的地址赋给 p
    p = max;      //max 为已定义的函数，将 max 的入口地址赋值给 p
    p1 = p2;      //p1 和 p2 都是同类型的指针变量，将 p2 的值赋给 p1
    ```

    

3. 指针变量可以有空值，即该指针变量不指向任何变量

    ```cpp
    p = nullptr;
    ```

    ::: tip NULL 、0 和 nullptr 的区别

    - NULL 在c++中是一个宏，是一个空指针常量，如果将NULL扩展为常数，那么这个数是0，类型为int。所以，常数0既是整型常量，也是空指针常量，这就有可能导致二义性问题。因此，c++11新标准引入了 nullptr，将其作为空指针常量（特殊的字面常量，能够转化为任何类型的指针）。

    - NULL 在C++中就是0，这是因为在C++中 void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。

    - 所以，C++11加入了 nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用 nullptr 替代 NULL，而NULL就当做0使用。

    - ==野指针的情况非常危险，在引用指针变量之前应该对其赋值==

    - 任何指针变量或地址都可以与空指针比较

    :::

4. 两个指针变量可以相减

    如果两个指针变量指向同一个数组元素，则两个指针变量值之差是两个指针之间的元素个数

    - 假如 `p1` 指向 `a[1]`，`p2` 指向 `a[4]`,则 `p2 - p1 = a+4 -(a+1)=3`
    - 但是 `p1+p2` 没有意义

5. 两个指针变量比较

    - 若**两个指针指向同一个数组的元素，则可以比较**，
    - 指向不同数组的指针比较没有意义
    - 指向**前面的元素**的**指针变量**==小于==指向**后面元素**的**指针变量**
        - 上例中表达式 “p2 > p1” 的值为真;

6. 对指针赋值应该注意类型问题

    - 不同类型的指针变量之间不能相互赋值
    - 如果一定要对不同类型的指针变量赋值，可以用强制类型转换

    ​		例，

    ```cpp
    int *p1;char *p2;float *p3;
    p1 = (int *)p2;   //将 p2 的值强制转换为指向整型数据的指针类型，并赋值给 p1
    p2 = (char *)p3;
    p3 = (float *)p1;
    ```

    

### 内存泄漏（Memory Leak）

是指程序中已动态分配的'堆内存'由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。