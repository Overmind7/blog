

# 虚函数与动态多态性

## 利用虚函数实现动态多态性

### 虚函数

#### 引入

**回顾**

在同一类中不能定义两个名字相同，参数个数和类型都相同的函数（重复定义）。

在类的继承结构中，在不同的层次中可以出现名字相同，参数个数类型都相同而功能不同的函数。

这是合法的，编译系统按照'同名覆盖'的原则决定调用对象。

如果想要调用基类的同名函数，需要用 基类名加'**域运算符**' 区分同名函数，例

```cpp
cy1.Circle::area();
```

对于 **同名数据成员**：

⚠️当派生类中的成员变量和基类中同名，那么与函数同名一样，基类中的同名变量会被隐藏。

- 也就是**通过派生类对象无法访问基类的同名变量**

  

**能否用同一个调用形式来调用派生类和基类的同名函数？？**

在程序中不是通过对象名去调用不同派生层次的同名函数

而是通过 **指针 调用**！！

调用前临时将指针变量 pt 赋予不同的值

-----------------------------

#### 虚函数概念

==基类声明函数是虚拟的==，并不是实际存在的函数，然后在派生类中才正式定义此函数

在程序运行期间，用指针指向某一派生类对象

这样就能调用指针指向的派生类对象中的函数，而不会调用其他派生类中的函数



#### 虚函数的作用

允许在派生类中重新定义与基类同名的函数，

并且可以通过基类指针或引用来访问基类和派生类中的同名函数



::: tip 类族

如果基类有多个派生类，每个派生类又产生新的派生类，形成了同一基类的类族

:::



#### 举例

```cpp
#include <iostream>
#include <string>

using namespace std;

class student{
  public:
    student(int n,string nam,float s);  //声明构造函数
    void display();           //声明输出函数
  protected:     //受保护的成员，派生类可以访问
    int num;
    string name;
    float score;
};

student::student(int n,string nam,float s){
  num = n;
  name = nam;
  score = s;
}

void student::display(){
  cout<<"num: "<<num
    <<"\nname: "<<name
    <<"\nscore: "<<score
    <<"\n\n";
}

class graduate:public student{
  public:
    graduate(int,string,float,float);  //声明构造函数
    void display();       //声明输出函数，与基类的输出函数同名
  private:
    float wage;
};

graduate::graduate(int n,string nam,float s,float w):student(n,nam,s),wage(w){}

void graduate::display(){
  cout<<"num: "<<num
    <<"\nname: "<<name
    <<"\nscore: "<<score
    <<"\nwage: "<<wage<<endl;
}

int main(){
  student stud1(1001,"LI",33.3);
  graduate grad1(2002,"gan",12.2,1222);
  student *pt = &stud1;
  pt->display();
  pt = &grad1;
  pt->display();
  return 0;
}
```

​    运行结果：没有出现 wage 的数据！！！

​    程序分析：

​      用指向父类的指针输出父类数据后，将指针指向派生类，试图输出 grad1 的全部数据成员

​      但是只输出类 grad1 中基类的数据成员

​      说明没有调用 grad1 中的 display 函数（基类指针指向的是派生类对象中的基类部分）

​      

::: tip 其他方法：（不使用虚函数）

1、通过对象名调用 display 函数，例 `grad1.display()`

按照同名覆盖的方法，如果要调用基类的 `display()`

```cpp
grad1.sutdent::display();
```

2、定义一个指向派生类的指针 p，再有 `p->display()`

3、定义指向基类的指针 p 指向派生类，调用 `p->display()`

则只能调用其中的继承的基类的 `display()` 函数，而不是派生类的 `display()`

这些方法都不方便

> 如果派生类中改名为如 `dispaly1`，也不行，因为指向的派生类中的基类没有此成员函数

:::



​      

::: tip

​    问题：如何用同一种方式去调用同一类族中不同类的所有同名函数？？

​    解决方法：使用虚函数

:::

​      在基类 student 的 display 函数声明前加上关键字 virtual

​      virtual void dispaly()

​    用同一种调用形式 pt->display()，且 pt 是同一个基类的指针，调用同一类族的不同虚函数

​    这些就实现了对同一消息不同对象有不同的响应方式（多态性）



  4、虚函数的作用

​    1、原理

​      基类中的函数被声明为虚函数，在声明派生类时被重载

​      派生类的同名函数取代了基类中的虚函数

​      因此在使用基类指针指向派生类对象后，调用 display 函数时调用了派生类的 display 函数

​      注意⚠️：只有通过 virtual 声明了函数为虚函数后才行，试图通过基类指针调用派生类的非虚函数是不行的

​    2、作用

​      其他方式的缺点

​        类的继承目的是保留基类的特性，但是从基类继承的某些成员函数无法满足新的需要

​        可以使函数名字不同，如果派生类过多也不方便

​        如果名字相同会出现同名覆盖

​      虚函数

​        把基类的某个成员函数声明为虚函数之后，允许在其派生类中对函数重新定义，赋予新的功能

​        并且可以通过指向基类的指针指向同一类族中不同类的对象，从而调用其中的同名函数

​        

::: tip 由虚函数实现的多态性实质就是

​    同一类族中不同类的对象，对同一函数调用做出不同的响应

:::



  5、虚函数使用方法

​    1、在基类中用 virtual 声明成员函数为虚函数，在类外定义虚函数时，不必再加 virtual

​    2、在派生类中重新定义此函数

​      函数名、函数类型、函数参数个数和类型必须与基类的虚函数相同

​      根据派生类的需要重新定义函数体

​        当一个成员函数被声明为虚函数后

​          派生类中的同名函数都自动成为虚函数

​          派生类中重新声明该虚函数时，可加可不加 virtual（为了易读性，最好每一层都加）

​      如果派生类中没有对基类的虚函数重新定义：

​        派生类简单地继承'直接基类的虚函数'

​    3、定义一个指向基类的指针变量，并使它指向同一类族中需要调用该函数的对象

​    4、通过该指针变量调用此虚函数，调用的是指针变量指向对象的同名虚函数

​    5、在什么情况下声明虚函数？？

::: warning

1. 只能用 virtual 声明类的成员函数，而不能声明类外的普通函数为虚函数
2. 一个成员函数被声明为虚函数后，在同一类族中的类不能再定义一个 非virtual 的但与该虚函数具有相同参数和函数返回值类型的同名函数类

:::

​      2、考虑一下几点

​        1、看成员函数所在的类是否会作为基类，在类继承后有无可能被更改功能

​        2、如果成员函数在类被继承后功能无需修改，或者派生类用不到该函数（不要把基类所有函数都声明为虚函数）

​        3、考虑对成员函数的调用是通过对象名、基类指针 还是 引用 去访问

​          如果通过 基类指针 或者 引用访问的，应当声明为虚函数

​        4、有时定义虚函数时并不定义函数体（纯虚函数）

  6、总结

​    通过虚函数与指向基类对象的指针变量的配合使用，就能实现动态的多态性

​      如果想调用同一类族中不同类的同名函数，只要现用基类指针指向该类对象即可

​      如果指针先后指向同一类族中不同类的对象，就能不断地调用指向对象中的同名函数

​    如果在基类中定义的'非虚函数'在派生类中重新定义

​      如果用'基类指针'调用该成员函数，则会调用对象中基类部分的成员函数

​      如果用'派生类指针'调用该成员函数，系统会调用派生类对象中的成员函数

​      这使用的是不同类型的指针，而不是多态性！！

​    函数重载：'横向重载'同一层次上的同名函数，函数首部不同

​    虚函数：'纵向重载'不同派生层次上的同名函数，虚函数函数首部相同！



::: tip 使用虚函数会有空间开销！！

当一个类带有虚函数时，编译系统会为该类增加一个 ==虚函数表 VFT==，是一个指针数组

- （用sizeof可以知道带虚函数的类字节数更多），

存放每个虚函数的入口地址

系统在进行动态关联时的时间开销是很少的，因此多态性是高效的

:::

## 静态关联与动态关联

**关联：**

​    确定调用的具体对象的过程称为'关联' binding（联编、束定、编联）

**静态关联**：

​    函数重载和通过对象名调用的虚函数，在编译时就可以确定其调用的虚函数属于哪个类，这种过程被称为'静态关联' （static binding）

​      例如用 inline 声明的函数

​    由于是在运行前进行关联的，又称为'早期关联'（early binding）

**动态关联**：

​    定义基类指针指向派生类并调用其中的虚函数时，编译系统只做静态的语法检查，无法确定 `pt->dispaly()` 调用的是哪个对象

​    因此在运行阶段处理，在运行阶段把虚函数和类对象绑定的过程称为'动态关联'（dynamic binding）

​    动态的多态性，运行阶段的多态性

​    由于是在编译之后的运行阶段进行的，因此也被称为'滞后关联'late binding

​    动态联编的条件：

​      1、被调用的成员函数是虚函数

​      2、用指针或者引用调用虚函数