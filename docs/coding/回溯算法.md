# 回溯算法

回溯是递归的副产品，只要有递归就会有回溯。

> [回溯算法理论基础](https://programmercarl.com/回溯算法理论基础.html#理论基础)

![回溯算法理论基础](https://raw.githubusercontent.com/Overmind7/images/main/img/20210130173631174.png)

```text
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**回溯法解决的问题**

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等



## 1. 组合问题



### [77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex){
        if(path.size() == k){
            result.push_back(path);
            return;
        }
        // for(startIndex; startIndex <= n; startIndex++){
        // 剪枝优化,这里k个数里已经有了path.size()个了,不需要把n遍历完,
        // 要算上从 starindex开始的自己,闭区间
        // for(startIndex; startIndex <= n - (k - path.size() - 1); startIndex++){
        // 这样写更容易理解,已经加入path的数量和n中剩余的数量要大于k
        for(startIndex; n - (startIndex - 1) + path.size() >= k; startIndex++){
            path.push_back(startIndex);
            backtracking(n, k, startIndex+1);
            path.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
};
```



### [216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/)

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtrack(int k, int n, int starIndex){
        // 剪枝
        if(n < 0) return;

        if(n == 0 && path.size() == k){
            result.push_back(path);
            return;
        }
        for(starIndex; starIndex <= 9; starIndex++){
            path.push_back(starIndex);

            backtrack(k, n - starIndex, starIndex + 1);
            path.pop_back();
        }

    }

    vector<vector<int>> combinationSum3(int k, int n) {
        backtrack(k,n,1);
        return result;

    }
};
```

### [17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```cpp
class Solution {
public:
    vector<string> result;
    string path;
    unordered_map<char, string> map;

    void backtrack(string digits, int depth){
        int length = digits.size();
        if(length == depth-2){
            result.push_back(path);
            return;
        }
        string cur = map[digits[depth-2]];
        for(int i = 0; i < cur.size(); i++){
            path.push_back(cur[i]);
            backtrack(digits, depth+1);
            path.pop_back();
        }
    }

    vector<string> letterCombinations(string digits) {
        map['2'] = "abc";
        map['3'] = "def";
        map['4'] = "ghi";
        map['5'] = "jkl";
        map['6'] = "mno";
        map['7'] = "pqrs";
        map['8'] = "tuv";
        map['9'] = "wxyz";
        if(digits.size() == 0) return result;
        backtrack(digits, 2);
        return result;

    }
};
```

可以简化，使用字符串数组，这样 depth 也不用-2了

```cpp
const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs", // 7
    "tuv", // 8
    "wxyz", // 9
};
```



### [39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)

和前面组合总和的区别是可以重复取数

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtrack(vector<int>& candidates, int target, int startIndex){
        if(target < 0) return;
        if(target == 0){
            result.push_back(path);
            return;
        }
        for(startIndex; startIndex < candidates.size(); startIndex++){
            path.push_back(candidates[startIndex]);
            
            // backtrack(candidates, target- candidates[startIndex], startIndex+1);
            // 如何重复取数
            // 这里 startIndex 不+1了表示不跳过自己遍历，可以取自己
            backtrack(candidates, target- candidates[startIndex], startIndex);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates, target, 0);
        return result;
    }
};
```



### [40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtrack(vector<int>& candidates, int target, int startIndex){
        if(target < 0) return;
        if(target == 0){
            result.push_back(path);
            return;
        }
        // for(startIndex; startIndex < candidates.size(); startIndex++){
        //     if(startIndex > 0 && candidates[startIndex] == candidates[startIndex-1]){
        //         continue;
        //     }
        // 1,1,2,5,6,7,10
        // 使用上面这种写法把1,1,6过滤掉了
        for(int i = startIndex; i < candidates.size(); i++){
            if(i > startIndex && candidates[i] == candidates[i-1]){
                continue;
            }
            path.push_back(candidates[i]);
            
            backtrack(candidates, target - candidates[i], i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, target, 0);
        return result;
    }
};
```

使用used数组





## 2. 分割问题

### [131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)

为什么切出的子串不是回文序列要跳过/剪枝？

```cpp
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path;
    bool is(string s){
        int i = 0;
        int j = s.size() - 1;
        while(i < j){
            if(s[i] == s[j]) {
                i++;
                j--;
            }
            else return false;
        }
        return true;
    }
    void backtrack(string s, int startIndex){
        if(startIndex >= s.size() ){
            result.push_back(path);
            return;
        }

        for(int i = startIndex; i< s.size(); i++){
            string sub = s.substr(startIndex, i-startIndex+1);
            if(is(sub)) {
                path.push_back(sub);
                backtrack(s, i + 1);
                path.pop_back();
            }
            // else continue;


            // backtrack(s, i + 1);
            // path.pop_back();

        }

    }
    vector<vector<string>> partition(string s) {
        backtrack(s,0);
        return result;

    }
};
```



### [93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/)

```cpp
class Solution {
public:
    vector<string> result;
    vector<string> path;
    bool is_valid(string s){
        if(s.size() > 1 && s[0] == '0') return false;
        if(s.size() > 3) return false;
        int index = stoi(s);
        if(index <= 255) return true;
        else return false;

    }
    void back(string s, int startIndex, int left_to_split){
        // left_to_split 保证完整分割
        if(path.size() == 4 && left_to_split == 0){
            result.push_back(path[0] + "." + path[1] + "." + path[2] + "." + path[3]);
            return;
        }
        for(int i = startIndex; i < s.size(); i++){
            
            string sub = s.substr(startIndex, i - startIndex + 1);
            if(is_valid(sub) ){
                path.push_back(sub);

                back(s, i+1, left_to_split-sub.size());
                path.pop_back();
            }
            else break;


        }
    }
    vector<string> restoreIpAddresses(string s) {
        int remain = s.size();
        back(s, 0, remain);
        return result;

    }
};
```



## 3. 子集问题

### [78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/description/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void back(vector<int>& nums, int startIndex){
        result.push_back(path);
        // 终止条件也可以不要
        // if(startIndex >= nums.size()){
            // 为什么要放在外面：放在里面会漏掉自己
            // result.push_back(path);
        //     return;
        // }
        for(int i = startIndex; i < nums.size(); i++){
            path.push_back(nums[i]);
            back(nums, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        back(nums, 0);
        return result;
    }
};
```

放在里面会漏掉自己

```
输入
nums =
[1,2,3,4]
输出
[[1,2,3,4],[1,2,4],[1,3,4],[1,4],[2,3,4],[2,4],[3,4],[4]]
预期结果
[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]
```



### [90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void back(vector<int>& nums, int startIndex){
        result.push_back(path);
        if(startIndex >= nums.size()){
            // 为什么要放在外面：放在里面会漏掉自己
            // 这里也可以不用返回条件
            return;
        }
        for(int i = startIndex; i < nums.size(); i++){
            if(i > startIndex && nums[i] == nums[i-1]) continue;
            else{
                path.push_back(nums[i]);
                back(nums, i+1);
                path.pop_back();
            }
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        back(nums, 0);
        return result;

    }
};
```

关于回溯算法中的去重问题，**在[40.组合总和II (opens new window)](https://programmercarl.com/0040.组合总和II.html)中已经详细讲解过了，和本题是一个套路**。

先排序，再去重

使用used数组





### [491. 递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

![491. 递增子序列1](https://raw.githubusercontent.com/Overmind7/images/main/img/20201124200229824-20230310131640070.png)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void back(vector<int>& nums, int startIndex){
        if(path.size() >= 2) result.push_back(path);
        if(startIndex >= nums.size()){
            return;
        }
		
        // 每一层的set都会重新声明
        unordered_set<int> set;
        for(int i = startIndex; i < nums.size(); i++){
            
            if(path.size() != 0 && nums[i] < path.back() || set.find(nums[i]) != set.end()) continue;
            set.insert(nums[i]);
            path.push_back(nums[i]);

            back(nums, i+1);
            path.pop_back();
        }
    }

    vector<vector<int>> findSubsequences(vector<int>& nums) {
        back(nums, 0);
        return result;
    }
};
```



## 4. 排列问题

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/)









## 5. 棋盘问题









## 6. 其他



