---
sidebar: auto
---



# 代码随想录题解

## 数组

二分

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

> [35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/)

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

> [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
>
> [283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)
>
> [844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/)
>
> > 只用了栈的方法

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

滑动窗口

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)

> [904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/)
>
> map  erase find  函数
>
> [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/)
>
> [滑动窗口](./滑动窗口.md)



模拟题

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)





[54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/description/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int top = 0;
        int bottom = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        vector<int> res;

        int t = matrix.size()*matrix[0].size();
        int cnt = 0;
        while(cnt < t ){
            for(int i = left; i <= right && cnt < t; i++,cnt++){
                res.push_back(matrix[top][i]);
            }
            top++;
            for(int i = top; i <= bottom && cnt < t; i++,cnt++){
                res.push_back(matrix[i][right]);
            }
            right--;
            for(int i = right; i >= left && cnt < t; i--,cnt++){
                res.push_back(matrix[bottom][i]);
            }
            bottom--;
            for(int i = bottom; i >= top && cnt < t; i--,cnt++){
                res.push_back(matrix[i][left]);
            }
            left++;
        }
        return res;
    }
};
```

[vector创建数组（一维、二维）的超详细总结_vector定义二维数组_半路杀出来的小黑同学的博客-CSDN博客](https://blog.csdn.net/m0_57298796/article/details/123952640)





C++ String

```c++
string s="234"；
s.insert(0,"01");
//此时s为01234
string s1="567";
int n=s.size();
s.insert(n,s1);
//此时s为01234567
s.insert(s.size(),3,'1');
//此时s为01234567111
s.erase(0,2);
//此时s为234567111


```

## 链表

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

```cpp
ListNode* removeElements(ListNode* head, int val) {
    // 使用一个虚拟头节点，避免单独处理头节点
    // 根据给出的定义，初始化虚拟头节点
    ListNode* dummyHead = new ListNode(0, head);
    // dummyHead->next = head;

    ListNode *cur = dummyHead;

    while(cur->next != NULL){
        if(cur->next->val == val){
            ListNode *tmp = cur->next;
            cur->next = cur->next->next;
            delete tmp;
        }
        else{
            cur = cur->next;
        }
    }

    // 原来的头节点有可能被删除，需要重新赋值指针
    head = dummyHead->next;
    delete dummyHead;

    return head;
}
```

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)

```cpp
class MyLinkedList {
private:
    struct ListNode{
        int val;
        ListNode* next;
        ListNode():val(0),next(nullptr){}
        ListNode(int v):val(v),next(nullptr){}
        ListNode(int v,ListNode* n):val(v),next(n){}
    };
    int _size;
    ListNode* _dummyHead;

public:
    MyLinkedList() {
        _size = 0;
        _dummyHead=new ListNode();
    }
    
    int get(int index) {
        if(index < 0 || index > _size-1) return -1;
        ListNode* cur = _dummyHead->next;
        while(index--){
            cur=cur->next;
        }
        return cur->val;
    }

    
    void addAtHead(int val) {
        ListNode*cur = _dummyHead->next;
        ListNode*tmp = new ListNode(val,cur);
        _dummyHead->next = tmp;
        _size++;
    }
    
    void addAtTail(int val) {
        ListNode*cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        ListNode*tmp = new ListNode(val);
        cur->next = tmp;
        _size++;
    }
    
    void addAtIndex(int index, int val) {
        ListNode*cur = _dummyHead;
        if(index > _size) return;
        if(index < 0) index = 0; 
        while(index--){
            cur = cur->next;
        }
        ListNode*tmp = new ListNode(val);
        tmp->next = cur->next;
        cur->next = tmp;
        _size++;
    }
    
    void deleteAtIndex(int index) {
        if(index < 0 || index > _size-1)return;
        ListNode* cur = _dummyHead;
        while(index--){
            cur = cur->next;
        }
        ListNode* tmp = cur->next;
        cur->next = tmp->next;
        delete tmp;
        tmp = nullptr;
        _size--;
    }
};
```



[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

- 双指针

    ```cpp
    class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
            ListNode* pre = nullptr;
            ListNode* cur = head;
    
            while(cur){
                ListNode* tmp = cur->next;
                cur->next = pre;
                pre=cur;
                cur=tmp;
            }
            return pre;
        }
    };
    ```

- 递归

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 边缘条件判断
        if(head == NULL) return NULL;
        if (head->next == NULL) return head;
        
        // 递归调用，翻转第二个节点开始往后的链表
        ListNode *last = reverseList(head->next);
        // 翻转头节点与第二个节点的指向
        head->next->next = head;
        // 此时的 head 节点为尾节点，next 需要指向 NULL
        head->next = NULL;
        return last;
    }
}; 
```



**[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)**

- 模拟

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* dummyHead = new ListNode(0,head);
        ListNode* tmp1 = dummyHead;
        while(tmp1->next != nullptr && tmp1->next->next != nullptr  ){
            ListNode* tmp2 = tmp1->next;
            ListNode* tmp3 = tmp2->next;

            tmp1->next = tmp3;
            tmp2->next = tmp3->next;
            tmp3->next = tmp2;

            tmp1=tmp2;
        }
        return dummyHead->next;
    }
};
```



- 递归

    递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。

    如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。

    - 用 head 表示原始链表的头节点，新的链表的第二个节点，用 `newHead`表示新的链表的头节点，原始链表的第二个节点，
    - 则原始链表中的其余节点的头节点是 `newHead->next`。令 `head->next = swapPairs(newHead->next)`，表示将其余节点进行两两交换，交换后的新的头节点为 `head` 的下一个节点。
    - 然后令 `newHead->next = head`，即完成了所有节点的交换。最后返回新的链表的头节点 `newHead`。

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* new_head = head->next;
        head->next = swapPairs(new_head->next);
        new_head->next = head;
        return new_head;
    }
};
```

> 和上一题的递归不同，但是相似，都是相同的子问题。



[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)



## 哈希表

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)

> [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)



[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/) 

[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/)





[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)



## 字符串

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)

[剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

