---
sidebar: auto
---



# 代码随想录题解

## 数组

二分

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

> [35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/)

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

> [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
>
> [283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)
>
> [844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/)
>
> > 只用了栈的方法

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

滑动窗口

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)

> [904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/)
>
> map  erase find  函数
>
> [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/)
>
> [滑动窗口](./滑动窗口.md)



模拟题

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)





[54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/description/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int top = 0;
        int bottom = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        vector<int> res;

        int t = matrix.size()*matrix[0].size();
        int cnt = 0;
        while(cnt < t ){
            for(int i = left; i <= right && cnt < t; i++,cnt++){
                res.push_back(matrix[top][i]);
            }
            top++;
            for(int i = top; i <= bottom && cnt < t; i++,cnt++){
                res.push_back(matrix[i][right]);
            }
            right--;
            for(int i = right; i >= left && cnt < t; i--,cnt++){
                res.push_back(matrix[bottom][i]);
            }
            bottom--;
            for(int i = bottom; i >= top && cnt < t; i--,cnt++){
                res.push_back(matrix[i][left]);
            }
            left++;
        }
        return res;
    }
};
```

[vector创建数组（一维、二维）的超详细总结_vector定义二维数组_半路杀出来的小黑同学的博客-CSDN博客](https://blog.csdn.net/m0_57298796/article/details/123952640)





C++ String

```c++
string s="234"；
s.insert(0,"01");
//此时s为01234
string s1="567";
int n=s.size();
s.insert(n,s1);
//此时s为01234567
s.insert(s.size(),3,'1');
//此时s为01234567111
s.erase(0,2);
//此时s为234567111


```

## 链表

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

```cpp
ListNode* removeElements(ListNode* head, int val) {
    // 使用一个虚拟头节点，避免单独处理头节点
    // 根据给出的定义，初始化虚拟头节点
    ListNode* dummyHead = new ListNode(0, head);
    // dummyHead->next = head;

    ListNode *cur = dummyHead;

    while(cur->next != NULL){
        if(cur->next->val == val){
            ListNode *tmp = cur->next;
            cur->next = cur->next->next;
            delete tmp;
        }
        else{
            cur = cur->next;
        }
    }

    // 原来的头节点有可能被删除，需要重新赋值指针
    head = dummyHead->next;
    delete dummyHead;

    return head;
}
```

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)

```cpp
class MyLinkedList {
private:
    struct ListNode{
        int val;
        ListNode* next;
        ListNode():val(0),next(nullptr){}
        ListNode(int v):val(v),next(nullptr){}
        ListNode(int v,ListNode* n):val(v),next(n){}
    };
    int _size;
    ListNode* _dummyHead;

public:
    MyLinkedList() {
        _size = 0;
        _dummyHead=new ListNode();
    }
    
    int get(int index) {
        if(index < 0 || index > _size-1) return -1;
        ListNode* cur = _dummyHead->next;
        while(index--){
            cur=cur->next;
        }
        return cur->val;
    }

    
    void addAtHead(int val) {
        ListNode*cur = _dummyHead->next;
        ListNode*tmp = new ListNode(val,cur);
        _dummyHead->next = tmp;
        _size++;
    }
    
    void addAtTail(int val) {
        ListNode*cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        ListNode*tmp = new ListNode(val);
        cur->next = tmp;
        _size++;
    }
    
    void addAtIndex(int index, int val) {
        ListNode*cur = _dummyHead;
        if(index > _size) return;
        if(index < 0) index = 0; 
        while(index--){
            cur = cur->next;
        }
        ListNode*tmp = new ListNode(val);
        tmp->next = cur->next;
        cur->next = tmp;
        _size++;
    }
    
    void deleteAtIndex(int index) {
        if(index < 0 || index > _size-1)return;
        ListNode* cur = _dummyHead;
        while(index--){
            cur = cur->next;
        }
        ListNode* tmp = cur->next;
        cur->next = tmp->next;
        delete tmp;
        tmp = nullptr;
        _size--;
    }
};
```



[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

- 双指针

    ```cpp
    class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
            ListNode* pre = nullptr;
            ListNode* cur = head;
    
            while(cur){
                ListNode* tmp = cur->next;
                cur->next = pre;
                pre=cur;
                cur=tmp;
            }
            return pre;
        }
    };
    ```

- 递归

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 边缘条件判断
        if(head == NULL) return NULL;
        if (head->next == NULL) return head;
        
        // 递归调用，翻转第二个节点开始往后的链表
        ListNode *last = reverseList(head->next);
        // 翻转头节点与第二个节点的指向
        head->next->next = head;
        // 此时的 head 节点为尾节点，next 需要指向 NULL
        head->next = NULL;
        return last;
    }
}; 
```



**[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)**

- 模拟

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* dummyHead = new ListNode(0,head);
        ListNode* tmp1 = dummyHead;
        while(tmp1->next != nullptr && tmp1->next->next != nullptr  ){
            ListNode* tmp2 = tmp1->next;
            ListNode* tmp3 = tmp2->next;

            tmp1->next = tmp3;
            tmp2->next = tmp3->next;
            tmp3->next = tmp2;

            tmp1=tmp2;
        }
        return dummyHead->next;
    }
};
```



- 递归

    递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。

    如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。

    - 用 head 表示原始链表的头节点，新的链表的第二个节点，用 `newHead`表示新的链表的头节点，原始链表的第二个节点，
    - 则原始链表中的其余节点的头节点是 `newHead->next`。令 `head->next = swapPairs(newHead->next)`，表示将其余节点进行两两交换，交换后的新的头节点为 `head` 的下一个节点。
    - 然后令 `newHead->next = head`，即完成了所有节点的交换。最后返回新的链表的头节点 `newHead`。

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* new_head = head->next;
        head->next = swapPairs(new_head->next);
        new_head->next = head;
        return new_head;
    }
};
```

> 和上一题的递归不同，但是相似，都是相同的子问题。



[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

两次遍历

```cpp
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummyHead = new ListNode(0,head);
    ListNode* cur = dummyHead;
    int cnt = 0;
    while( cur->next ){
        cur = cur->next;
        cnt++;
    }
    cur = dummyHead;
    int index = cnt - n;
    while( index--){
        cur = cur->next;
    }
    ListNode*tmp = cur->next;
    cur->next = tmp->next;
    delete tmp;
    head = dummyHead->next;
    delete dummyHead;
    return head;
}
```

一次遍历的话构造一个类似窗口的n长度，两个指针向后

```cpp
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummyHead = new ListNode(0,head);
    ListNode* left = dummyHead;
    ListNode* right = dummyHead;
    while( n-- ){
        right = right->next;
    }

    while( right->next ){
        left = left->next;
        right = right->next;
    }
    ListNode*tmp = left->next;
    left->next = tmp->next;
    delete tmp;
    head = dummyHead->next;
    delete dummyHead;
    return head;
}
```

[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

即使不相交，在各自遍历的AB链表之后，路程也是一样的，同时指向 nullptr

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* tmp1 = headA;
    ListNode* tmp2 = headB;
    while(tmp1 != tmp2){
        if(tmp1 == nullptr) tmp1 = headB;
        else tmp1 = tmp1->next;
        if(tmp2 == nullptr) tmp2 = headA;
        else tmp2 = tmp2->next;
    }
    return tmp1;
}
```

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

数学推导

> [代码随想录 (programmercarl.com)](https://programmercarl.com/0142.环形链表II.html#思路)

```cpp
ListNode *detectCycle(ListNode *head) {
    ListNode* fast = head;
    ListNode* slow = head;
    while(fast != nullptr && fast->next != nullptr){
        // 为什么这里要用 && ？
        // 逆反命题，保证 fast->next->next 有意义
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast){
            ListNode* x = slow;
            ListNode* index = head;
            while( x != index){
                x = x->next;
                index = index->next;
            }
            return index;
        }
    }
    return nullptr;
}
```



## 哈希表

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)

```cpp
bool isAnagram(string s, string t) {
    if(s.size() != t.size()) return false;
    int a[30]={0};
    for( int i = 0; i < s.size(); i++){
        a[s[i]-'a']++;
    }
    for(int i = 0; i < t.size(); i++){
        a[t[i]-'a']--;
    }
    for(auto i : a){
        if(i != 0) return false;
    }
    return true;
}
```

> [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)
>
> 



[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)

::: warning

`find()` 函数没有找到返回 `.end()` 指针

:::

```cpp
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int> nums1_set(nums1.begin(),nums1.end());
    unordered_set<int> nums2_set;
    for(auto i : nums2){
        if(nums1_set.find(i) != nums1_set.end()){
            nums2_set.insert(i);
        }
    }
    return vector<int>(nums2_set.begin(),nums2_set.end());
}
```

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)

```cpp
class Solution {
public:
    int getSum(int n){
        int sum = 0;
        while(n){
            sum += (n%10)*(n%10);
            n = n /10;
        }
        return sum;
    }
    bool isHappy(int n) {
        
        unordered_set<int> happy;
        while(true){
            int sum = getSum(n);
            if(sum == 1) return true;
            
            if(happy.find(sum) != happy.end()) return false;
            else happy.insert(sum);

            n = sum;
        }

    }
};
```



[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/) 

- 暴力解法
- 寻找 target - nums[i] （哈希）

[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/)





[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)



## 字符串

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)

[剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

