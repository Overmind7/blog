---
sidebar: auto
---



# 二叉树

## 1. 理论基础

链式储存二叉树

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

顺序储存

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220221144552.png)

> [01.树与二叉树的基础知识 | 算法通关手册 (itcharge.cn)](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)

从图中我们也可以看出节点之间的逻辑关系。

- 如果某二叉树节点（非叶子节点）的下标为 $i$，那么其左孩子节点下标为 $2∗i+1$，右孩子节点下标为 $2∗i+2$。
- 如果某二叉树节点（非根结点）的下标为$ i$，那么其根节点下标为 $(i−1)//2$。$//$ 表示整除。

对于完全二叉树（尤其是满二叉树）来说，采用顺序存储结构比较合适，它能充分利用存储空间；

而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。并且，由于顺序存储结构固有的一些缺陷，会使得二叉树的插入、删除等操作不方便，效率也比较低。

对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。



## 2. 递归遍历

**每次写递归，都按照这三要素来写**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

举例：中序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec){
        if(cur == nullptr) return;
        traversal(cur->left,vec);
        vec.push_back(cur->val);
        traversal(cur->right,vec);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```



## 3. 迭代遍历



二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
    1. 弹出栈顶元素 `node`，并访问该元素。
    2. 如果 `node` 的右子树不为空，则将 `node` 的右子树入栈。
    3. 如果 `node` 的左子树不为空，则将 `node` 的左子树入栈。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165249.png)



------------------

二叉树的中序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈。
3. 当根节点或者栈不为空时：
    1. 如果当前节点不为空，则循环遍历左子树，并不断将当前子树的根节点入栈。
    2. 如果当前节点为空，说明当前节点无左子树，则弹出栈顶元素 `node`，并访问该元素，然后尝试访问该节点的右子树。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165231.png)



--------------------

二叉树的后序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈，使用 `prev` 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕。
3. 当根节点或者栈不为空时，从当前节点开始：
    1. 如果当前节点有左子树，则不断遍历左子树，并将当前根节点压入栈中。
    2. 如果当前节点无左子树，则弹出栈顶元素 `node`。
    3. 如果栈顶元素 `node` 无右子树（即 `not node.right`）或者右子树已经访问完毕（即 `node.right == prev`），则访问该元素，然后记录前一节点，并将当前节点标记为空节点。
    4. 如果栈顶元素有右子树，则将栈顶元素重新压入栈中，继续访问栈顶元素的右子树。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165218.png)

> [02.二叉树的遍历知识 | 算法通关手册 (itcharge.cn)](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/#32-二叉树的中序遍历显式栈实现)



## 4. 层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165158.png)

二叉树的层序遍历是通过队列来实现的。具体步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 令根节点入队。
3. 当队列不为空时，求出当前队列长度 $S_i$。
4. 依次从队列中取出这 $S_i$ 个元素，并对这 $S_i$ 个元素依次进行访问。然后将其左右孩子节点入队，然后继续遍历下一层节点。
5. 当队列为空时，结束遍历。

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    vector<vector<int>> result;
    while(!que.empty()){
        int size = que.size();
        vector<int> res;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            res.push_back(tmp->val);
            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            que.pop();
        }
        result.push_back(res);
    }
    return result;
}
```

递归法：

```cpp
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth){
        // 确定参数和返回值
        // 确定终止条件
        if(cur == nullptr) return;
        // 确定单层递归条件
        // 在二维容器中新建一个空行
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth+1);
        order(cur->right, result, depth+1);
    }
    
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;

    }
};
```

[107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

和前面一样，最后翻转`vector<vector<int>> result;`

[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/)

- 使用递归，得到总的层序遍历，输出 每一行的 `back()`

```cpp
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth){
        if(cur == nullptr) return;
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result,depth+1);
        order(cur->right,result,depth+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        vector<vector<int>> tmp;
        int depth = 0;
        order(root, tmp, depth);

        vector<int> result;
        for(auto i = tmp.begin(); i != tmp.end(); i++){
            result.push_back((*i).back());
        }
        return result;
    }
};
```

- 使用迭代法，输出每一层的最后一个节点到 result 中

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();

            for(int i = 0; i < size; i++){
                TreeNode* tmp = que.front();
                if(i == size-1) result.push_back(tmp->val);
                if(tmp->left) que.push(tmp->left);
                if(tmp->right) que.push(tmp->right);
                que.pop();
            }
        }
        return result;
    }
};
```

[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

对每一层求平均值

```cpp
vector<double> averageOfLevels(TreeNode* root) {
    vector<double> result;
    // vector<vector<int>> vec;
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        double cnt = 0;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();
            cnt += tmp->val;
            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        result.push_back(double(cnt/size));
    }
    return result;
}
```

[429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

- 递归

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    void order(Node* cur, vector<vector<int>>& result, int depth){
        if(cur == nullptr) return;
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        for(auto i : cur->children){
            order(i,result,depth+1);
        }
    }
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

- 迭代

```cpp
vector<vector<int>> levelOrder(Node* root) {
    vector<vector<int>> result;
    queue<Node*> que;
    if(root != nullptr)que.push(root);
    while(!que.empty()){
        int size = que.size();
        vector<int> vec;
        for(int i = 0; i < size; i++){
            Node* tmp = que.front();
            que.pop();
            vec.push_back(tmp->val);
            for(auto i:tmp->children){
                if(i) que.push(i);
            }
            //for (int i = 0; i < node->children.size(); i++) { // 将节点孩子加入队列
            //        if (node->children[i]) que.push(node->children[i]);
            //}
        }
        
        result.push_back(vec);

    }
    return result;
}
```

[515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```cpp
vector<int> largestValues(TreeNode* root) {
    vector<int> result;
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        int index = INT_MIN;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();
            // if(tmp->val > index) index = tmp->val;
            index = index > tmp->val ? index : tmp->val;

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        result.push_back(index);
    }
    return result;
}
```

[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```cpp
Node* connect(Node* root) {
    if(root == nullptr || root->left == nullptr) return root;
    root->left->next = root->right;
    if(root->next != nullptr){
        root->right->next = root->next->left;
    }
    connect(root->left);
    connect(root->right);
    return root;
}
```



```cpp
Node* connect(Node* root) {
    queue<Node*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        Node* pre;
        Node* cur;
        for(int i = 0; i < size; i++){
            if(i == 0){
                pre = que.front();
                que.pop();
                cur = pre;
            }
            else{
                cur = que.front();
                que.pop();
                pre->next = cur;
                pre = pre->next;

            }
            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
    }
    return root;
}
```

[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

```cpp
Node* connect(Node* root) {
    queue<Node*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        Node* pre = nullptr;
        Node* cur = nullptr;
        for(int i = 0; i < size; i++){
            if(i == 0){
                pre = que.front();
                que.pop();
                cur = pre;
            }
            else{
                cur = que.front();
                que.pop();
                pre->next = cur;
                pre = pre->next;;
            }

            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
    }
    return root;
}
```

> 怎么用递归写呢？



### [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

深度优先搜索

```cpp
int maxDepth(TreeNode* root) {
    if( root == nullptr) return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

广度优先搜索

```cpp
int maxDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);

    int cnt = 0;
    while(!que.empty()){
        int size = que.size();

        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        cnt++;
    }
    return cnt;

}
```

### [559. N 叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if(root == nullptr) return 0;
        int maxChilderndepth = 0;
        for(auto i : root->children){
            int childDepth = maxDepth(i);
            maxChilderndepth = max(maxChilderndepth,childDepth);
        }
        return maxChilderndepth + 1;
    }
};
```



### [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

深度优先搜索

```cpp
int minDepth(TreeNode* root) {
    if(root == nullptr) return 0;
    if(root->left == nullptr && root->right == nullptr) return 1;

    int min_depth = INT_MAX;
    if( root->left != nullptr){
        min_depth = min(minDepth(root->left),min_depth);
    }
    if(root->right != nullptr){
        min_depth = min(minDepth(root->right),min_depth);
    }
    return min_depth+1;
}
```

广度优先搜索

**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

```cpp
int minDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    int depth = 0;
    while(!que.empty()){
        int size = que.size();
        depth++;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            if(tmp->left == nullptr && tmp->right==nullptr) return depth;               
        }
    }
    return depth;
}
```





## [6. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr) return root;
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    invertTree(root->right);        // 右
    return root;
}
```



## [7. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

不是层序遍历

```cpp
bool compare(TreeNode* left, TreeNode* right) {
    // 首先排除空节点的情况
    if (left == NULL && right != NULL) return false;
    else if (left != NULL && right == NULL) return false;
    else if (left == NULL && right == NULL) return true;
    // 排除了空节点，再排除数值不相同的情况
    else if (left->val != right->val) return false;

    // 此时就是：左右节点都不为空，且数值相同的情况
    // 此时才做递归，做下一层的判断
    bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
    bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
    bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
    return isSame;

}
bool isSymmetric(TreeNode* root) {
    if (root == NULL) return true;
    return compare(root->left, root->right);
}
```



### [相同的树 - 力扣](https://leetcode.cn/problems/same-tree/)

```cpp
bool isSameTree(TreeNode* left, TreeNode* right){
    if(left == nullptr && right != nullptr) return false;
    else if(left != nullptr && right == nullptr) return false;
    else if(left == nullptr && right == nullptr) return true;
    else if(left->val != right->val) return false;
    bool a = isSameTree(left->left,right->left);
    bool b = isSameTree(left->right,right->right);
    return a&&b;
}
```



### [另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)





## [8. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

- 按照普通二叉树遍历，时间复杂度为 n

```cpp
int countNodes(TreeNode* root) {
    if(root == nullptr) return 0;

    int left = countNodes(root->left);
    int right = countNodes(root->right);
    int sum = left + right + 1;
    return sum;
}
```

- 利用完全二叉树的性质

    - 时间复杂度：O(log n × log n)

    - 空间复杂度：O(log n)

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            // 2^n - 1
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

后序排序

```cpp
int rightTreeNum = countNodes(root->right);     // 右
int result = leftTreeNum + rightTreeNum + 1;    // 中
return result;
```



## [9. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

二叉树的高度：





二叉树的深度：

test



## [10. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

回溯



