# 二叉树

## 1. 理论基础

链式储存二叉树

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

顺序储存

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220221144552.png)

> [01.树与二叉树的基础知识 | 算法通关手册 (itcharge.cn)](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)

从图中我们也可以看出节点之间的逻辑关系。

- 如果某二叉树节点（非叶子节点）的下标为 $i$，那么其左孩子节点下标为 $2∗i+1$，右孩子节点下标为 $2∗i+2$。
- 如果某二叉树节点（非根结点）的下标为$ i$，那么其根节点下标为 $(i−1)//2$。$//$ 表示整除。

对于完全二叉树（尤其是满二叉树）来说，采用顺序存储结构比较合适，它能充分利用存储空间；

而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。并且，由于顺序存储结构固有的一些缺陷，会使得二叉树的插入、删除等操作不方便，效率也比较低。

对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。



## 2. 递归遍历

**每次写递归，都按照这三要素来写**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)



举例：中序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec){
        if(cur == nullptr) return;
        traversal(cur->left,vec);
        vec.push_back(cur->val);
        traversal(cur->right,vec);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```



## 3. 迭代遍历



二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
    1. 弹出栈顶元素 `node`，并访问该元素。
    2. 如果 `node` 的右子树不为空，则将 `node` 的右子树入栈。
    3. 如果 `node` 的左子树不为空，则将 `node` 的左子树入栈。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165249.png)

```cpp
vector<int> preorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> result;

    if(root != nullptr) st.push(root);
    while(!st.empty()){
        TreeNode* tmp = st.top();
        st.pop();

        result.push_back(tmp->val);

        if(tmp->right) st.push(tmp->right);
        if(tmp->left) st.push(tmp->left);

    }
    return result;
}
```



------------------

二叉树的中序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈。
3. 当根节点或者栈不为空时：
    1. 如果当前节点不为空，则循环遍历左子树，并不断将当前子树的根节点入栈。
    2. 如果当前节点为空，说明当前节点无左子树，则弹出栈顶元素 `node`，并访问该元素，然后尝试访问该节点的右子树。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165231.png)

```cpp
vector<int> inorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> result;
    TreeNode* cur = root;

    while(cur || !st.empty()){
        if(cur){
            st.push(cur);
            cur = cur->left;
        }
        else{
            cur = st.top();
            st.pop();
            result.push_back(cur->val);
            cur = cur->right;
        }
    }
    return result;
}
```



--------------------

二叉树的后序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈，使用 `prev` 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕。
3. 当根节点或者栈不为空时，从当前节点开始：
    1. 如果当前节点有左子树，则不断遍历左子树，并将当前根节点压入栈中。
    2. 如果当前节点无左子树，则弹出栈顶元素 `node`。
    3. 如果栈顶元素 `node` 无右子树（即 `not node.right`）或者右子树已经访问完毕（即 `node.right == prev`），则访问该元素，然后记录前一节点，并将当前节点标记为空节点。
    4. 如果栈顶元素有右子树，则将栈顶元素重新压入栈中，继续访问栈顶元素的右子树。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165218.png)

```cpp
// 或者改变前序入栈顺序，最后reverse数组
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;

    if(root) st.push(root);
    while(!st.empty()){
        TreeNode* tmp = st.top();
        st.pop();

        result.push_back(tmp->val);
        if(tmp->left) st.push(tmp->left);
        if(tmp->right) st.push(tmp->right);
    }
    reverse(result.begin(), result.end());
    return result;

}
```



> [02.二叉树的遍历知识 | 算法通关手册 (itcharge.cn)](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/#32-二叉树的中序遍历显式栈实现)



## 4. 层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165158.png)

二叉树的层序遍历是通过队列来实现的。具体步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 令根节点入队。
3. 当队列不为空时，求出当前队列长度 $S_i$。
4. 依次从队列中取出这 $S_i$ 个元素，并对这 $S_i$ 个元素依次进行访问。然后将其左右孩子节点入队，然后继续遍历下一层节点。
5. 当队列为空时，结束遍历。

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    vector<vector<int>> result;
    while(!que.empty()){
        int size = que.size();
        vector<int> res;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            res.push_back(tmp->val);
            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            que.pop();
        }
        result.push_back(res);
    }
    return result;
}
```

递归法：

```cpp
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth){
        // 确定参数和返回值
        // 确定终止条件
        if(cur == nullptr) return;
        // 确定单层递归条件
        // 在二维容器中新建一个空行
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth+1);
        order(cur->right, result, depth+1);
    }
    
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;

    }
};
```

[107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

和前面一样，最后翻转`vector<vector<int>> result;`

[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/)

- 使用递归，得到总的层序遍历，输出 每一行的 `back()`

```cpp
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth){
        if(cur == nullptr) return;
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result,depth+1);
        order(cur->right,result,depth+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        vector<vector<int>> tmp;
        int depth = 0;
        order(root, tmp, depth);

        vector<int> result;
        for(auto i = tmp.begin(); i != tmp.end(); i++){
            result.push_back((*i).back());
        }
        return result;
    }
};
```

- 使用迭代法，输出每一层的最后一个节点到 result 中

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();

            for(int i = 0; i < size; i++){
                TreeNode* tmp = que.front();
                if(i == size-1) result.push_back(tmp->val);
                if(tmp->left) que.push(tmp->left);
                if(tmp->right) que.push(tmp->right);
                que.pop();
            }
        }
        return result;
    }
};
```

[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

对每一层求平均值

```cpp
vector<double> averageOfLevels(TreeNode* root) {
    vector<double> result;
    // vector<vector<int>> vec;
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        double cnt = 0;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();
            cnt += tmp->val;
            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        result.push_back(double(cnt/size));
    }
    return result;
}
```

[429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

- 递归

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    void order(Node* cur, vector<vector<int>>& result, int depth){
        if(cur == nullptr) return;
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        for(auto i : cur->children){
            order(i,result,depth+1);
        }
    }
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

- 迭代

```cpp
vector<vector<int>> levelOrder(Node* root) {
    vector<vector<int>> result;
    queue<Node*> que;
    if(root != nullptr)que.push(root);
    while(!que.empty()){
        int size = que.size();
        vector<int> vec;
        for(int i = 0; i < size; i++){
            Node* tmp = que.front();
            que.pop();
            vec.push_back(tmp->val);
            for(auto i:tmp->children){
                if(i) que.push(i);
            }
            //for (int i = 0; i < node->children.size(); i++) { // 将节点孩子加入队列
            //        if (node->children[i]) que.push(node->children[i]);
            //}
        }
        
        result.push_back(vec);

    }
    return result;
}
```

[515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```cpp
vector<int> largestValues(TreeNode* root) {
    vector<int> result;
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        int index = INT_MIN;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();
            // if(tmp->val > index) index = tmp->val;
            index = index > tmp->val ? index : tmp->val;

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        result.push_back(index);
    }
    return result;
}
```

[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```cpp
Node* connect(Node* root) {
    if(root == nullptr || root->left == nullptr) return root;
    root->left->next = root->right;
    if(root->next != nullptr){
        root->right->next = root->next->left;
    }
    connect(root->left);
    connect(root->right);
    return root;
}
```



```cpp
Node* connect(Node* root) {
    queue<Node*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        Node* pre;
        Node* cur;
        for(int i = 0; i < size; i++){
            if(i == 0){
                pre = que.front();
                que.pop();
                cur = pre;
            }
            else{
                cur = que.front();
                que.pop();
                pre->next = cur;
                pre = pre->next;

            }
            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
    }
    return root;
}
```

[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

```cpp
Node* connect(Node* root) {
    queue<Node*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        Node* pre = nullptr;
        Node* cur = nullptr;
        for(int i = 0; i < size; i++){
            if(i == 0){
                pre = que.front();
                que.pop();
                cur = pre;
            }
            else{
                cur = que.front();
                que.pop();
                pre->next = cur;
                pre = pre->next;;
            }

            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
    }
    return root;
}
```

> 怎么用递归写呢？



### [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> 根节点深度为 1

深度优先搜索

```cpp
int maxDepth(TreeNode* root) {
    if( root == nullptr) return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

广度优先搜索

```cpp
int maxDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);

    int cnt = 0;
    while(!que.empty()){
        int size = que.size();

        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        cnt++;
    }
    return cnt;

}
```

### [559. N 叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if(root == nullptr) return 0;
        int maxChilderndepth = 0;
        for(auto i : root->children){
            int childDepth = maxDepth(i);
            maxChilderndepth = max(maxChilderndepth,childDepth);
        }
        return maxChilderndepth + 1;
    }
};
```



### [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

深度优先搜索

```cpp
int minDepth(TreeNode* root) {
    if(root == nullptr) return 0;
    if(root->left == nullptr && root->right == nullptr) return 1;

    int min_depth = INT_MAX;
    if( root->left != nullptr){
        min_depth = min(minDepth(root->left),min_depth);
    }
    if(root->right != nullptr){
        min_depth = min(minDepth(root->right),min_depth);
    }
    return min_depth+1;
}
```

广度优先搜索

**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

```cpp
int minDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    int depth = 0;
    while(!que.empty()){
        int size = que.size();
        depth++;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            if(tmp->left == nullptr && tmp->right==nullptr) return depth;               
        }
    }
    return depth;
}
```





## [6. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr) return root;
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    invertTree(root->right);        // 右
    return root;
}
```



## [7. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

不是层序遍历

```cpp
bool compare(TreeNode* left, TreeNode* right) {
    // 首先排除空节点的情况
    if (left == NULL && right != NULL) return false;
    else if (left != NULL && right == NULL) return false;
    else if (left == NULL && right == NULL) return true;
    // 排除了空节点，再排除数值不相同的情况
    else if (left->val != right->val) return false;

    // 此时就是：左右节点都不为空，且数值相同的情况
    // 此时才做递归，做下一层的判断
    bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
    bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
    bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
    return isSame;

}
bool isSymmetric(TreeNode* root) {
    if (root == NULL) return true;
    return compare(root->left, root->right);
}
```



### [相同的树 - 力扣](https://leetcode.cn/problems/same-tree/)

```cpp
bool isSameTree(TreeNode* left, TreeNode* right){
    if(left == nullptr && right != nullptr) return false;
    else if(left != nullptr && right == nullptr) return false;
    else if(left == nullptr && right == nullptr) return true;
    else if(left->val != right->val) return false;
    bool a = isSameTree(left->left,right->left);
    bool b = isSameTree(left->right,right->right);
    return a&&b;
}
```



### [另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)





## [8. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

- 按照普通二叉树遍历，时间复杂度为 n

```cpp
int countNodes(TreeNode* root) {
    if(root == nullptr) return 0;

    int left = countNodes(root->left);
    int right = countNodes(root->right);
    int sum = left + right + 1;
    return sum;
}
```

- 利用完全二叉树的性质

    - 时间复杂度：O(log n × log n)

    - 空间复杂度：O(log n)

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            // 2^n - 1
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

后序排序

```cpp
int rightTreeNum = countNodes(root->right);     // 右
int result = leftTreeNum + rightTreeNum + 1;    // 中
return result;
```



## [9. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

二叉树的高度：





二叉树的深度：

> https://leetcode.cn/problems/balanced-binary-tree/solutions/8737/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/



![Picture1.png](https://raw.githubusercontent.com/Overmind7/images/main/img/1603024695-GYNvjf-Picture1.png)

**使用 -1 标记，剪枝已经不符合条件的子树**

```cpp
class Solution {
public:
    int recur(TreeNode* root){
        if(root == nullptr) return 0;
        
        int left = recur(root->left);
        if(left == -1) return -1;
        int right = recur(root->right);
        if(right == -1) return -1;
        
        int relative = abs(left - right);

        if(relative < 2) return max(left,right)+1;
        else return -1;
    }
    bool isBalanced(TreeNode* root) {
        return recur(root) != -1;
    }
};
```

单层递归的逻辑

如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。



## [10. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)



给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

- 回溯

> https://leetcode.cn/problems/binary-tree-paths/solutions/400434/257-er-cha-shu-de-suo-you-lu-jing-tu-wen-jie-xi-by/



```cpp
class Solution {
public:
    void preorder(TreeNode* cur, string path, vector<string>& result){
        if(cur == nullptr) return;

        if(cur->left == nullptr && cur->right == nullptr){
            result.push_back( path + to_string(cur->val));
            // "->" 放在这里会导致第一个路径也有这个，所以放在后面
            return;
        } 

        preorder(cur->left, path + to_string(cur->val) + "->", result);
        preorder(cur->right, path + to_string(cur->val) + "->", result);

    }
    vector<string> binaryTreePaths(TreeNode* root) {
        // 使用前序遍历
        vector<string> result;
        preorder(root, "", result);
        return result;
    }
};
```

为什么这里用了回溯？

preorder 的参数 path 不带引用和指针，是复制过来的，对上层没有影响

- 递归：

假设 root 的左右子树的 path 已经求出来了

```cpp
vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> result;
    if(root == nullptr) return result;
    if(root->left == nullptr && root->right == nullptr) {
        result.push_back(to_string(root->val));
    }

    for( auto path : binaryTreePaths(root->left)){
        result.push_back(to_string(root->val) + "->" + path);
    }
    for( auto path : binaryTreePaths(root->right)){
        result.push_back(to_string(root->val) + "->" + path);
    }
    return result;
}
```



- 迭代

```cpp
vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> result;
    queue<TreeNode*> que;
    queue<string> path;
    if(root != nullptr){
        que.push(root);
        path.push(to_string(root->val));
    }
    while(!que.empty()){
        TreeNode* cur = que.front();
        string cur_path = path.front();
        que.pop();
        path.pop();

        if(cur->left == nullptr && cur->right == nullptr){
            result.push_back(cur_path);
        }
        if(cur->left){
            que.push(cur->left);
            path.push(cur_path + "->" + to_string(cur->left->val));
        }
        if(cur->right){
            que.push(cur->right);
            path.push(cur_path + "->" + to_string(cur->right->val));

        }
    }
    return result;
}
```



## [11. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

![图二](https://raw.githubusercontent.com/Overmind7/images/main/img/20220902165805.png)

如何判断左叶子，不是二叉树的左侧节点

```cpp
class Solution {
public:
    void order(TreeNode* cur, int& cnt){
        if(cur == nullptr) return;
        // 如果判断左叶子
        if(cur->left && cur->left->left == nullptr && cur->left->right == nullptr){
            cnt += cur->left->val;
        }
        order(cur->left, cnt);
        order(cur->right, cnt);
        // cnt = order(cur->left, cnt) + order(cur->right, cnt);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        int cnt = 0;
        order(root, cnt);
        return cnt;
    }
};
```

更简单的写法

```cpp
int sumOfLeftLeaves(TreeNode* cur){
    if(cur == nullptr) return 0;
    // 如果判断左叶子
    int left = 0;
    if(cur->left && cur->left->left == nullptr && cur->left->right == nullptr){
        left =cur->left->val;
    }
    return left + sumOfLeftLeaves(cur->left) + sumOfLeftLeaves(cur->right);
}
```

## [12. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

- 层序遍历

```cpp
int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    int result;
    while(!que.empty()){
        int size = que.size();

        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            if(i == 0) result = tmp->val;

            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
    }
    return result;

}
```

- 迭代



## [13. 路径总和](https://leetcode.cn/problems/path-sum/)

- 递归

```cpp
bool hasPathSum(TreeNode* root, int targetSum) {
    if(root == nullptr) return false;

    if(root->left == nullptr && root->right == nullptr && root->val == targetSum){
        return true;
    }

    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum- root->val);



}
```

- 迭代（与 二叉树所有路径类似）
    - bfs，层序遍历

```cpp
bool hasPathSum(TreeNode* root, int targetSum) {
    // 层序遍历
    queue<TreeNode*> que;
    queue<int> cnt;
    if(root != nullptr){
        que.push(root);
        cnt.push(root->val);
    }
    while(!que.empty()){
        TreeNode* tmp_node = que.front();
        int tmp_val = cnt.front();
        que.pop();
        cnt.pop();

        if(tmp_node->left == nullptr && tmp_node->right == nullptr){
            if(tmp_val == targetSum) return true;
        }
        if(tmp_node->left){
            que.push(tmp_node->left);
            cnt.push(tmp_val + tmp_node->left->val);
        }
        if(tmp_node->right){
            que.push(tmp_node->right);
            cnt.push(tmp_val + tmp_node->right->val);
        }
    }
    return false;
}
```

::: tip 确定递归函数的参数和返回类型

参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

:::

[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/)

> 把当前的结点（叫他N1吧）加入数组中，然后去遍历他的左孩子，左孩子的所有孩子结点都遍历完之后，又回到了N1，
>
> 如果你这时候pop了，相当于把N1这个结点去掉了，而你这个时候还没有递归调用N1的右孩子结点，当你递归N1的右节点，数组里N1的值就已经被你pop了，就这出现问题了呀。
>
> 只有当递归调用完N1的左右孩子才能pop当前这个N1的结点，这就是为什么只需要一次删除，况且你一个N1节点只加入了一次，当然是pop一次了。

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(TreeNode* root, int targetSum){
        if(root == nullptr) return;

        targetSum -= root->val;
        path.push_back(root->val);

        if(!root->left && !root->right && targetSum == 0){
            res.push_back(path);
        }

        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root,targetSum);
        return res;

    }
};
```



## 14.二叉树的还原

::: warning

**已知二叉树的前序遍历序列和后序遍历序列，是不能唯一地确定一棵二叉树的。**

:::

> **二叉树的还原**：指的是通过二叉树的遍历序列，还原出对应的二叉树。

我们先来回顾一下二叉树的前序遍历、中序遍历、后序遍历规则。

- 非空二叉树的前序遍历规则：
    1. 访问根节点。
    2. 以前序遍历的方式遍历根节点的左子树。
    3. 以前序遍历的方式遍历根节点的右子树。
- 非空二叉树的中序遍历规则：
    1. 以中序遍历的方式遍历根节点的左子树。
    2. 访问根节点。
    3. 以中序遍历的方式遍历根节点的右子树。
- 非空二叉树的后序遍历规则：
    1. 以后序遍历的方式遍历根节点的左子树。
    2. 以后序遍历的方式遍历根节点的右子树。
    3. 访问根节点。



**如果已知一棵二叉树的前序序列和中序序列，可以唯一地确定这棵二叉树。**

同理，**如果已知一棵二叉树的中序序列和后序序列，也可以唯一地确定这棵二叉树。** 方法和通过二叉树的前序序列和中序序列构造二叉树类似，唯一不同点在于二叉树的根节点是根据后序遍历序列的最后一个元素确定的。

类似的，**已知二叉树的「中序遍历序列」和「层序遍历序列」，也可以唯一地确定一棵二叉树。**

需要注意的是：**如果已知二叉树的「前序遍历序列」和「后序遍历序列」，是不能唯一地确定一棵二叉树的。** 这是因为没有中序遍历序列无法确定左右部分，也就无法进行子序列的分割。

只有二叉树中每个节点度为 2 或者 0 的时候，已知前序遍历序列和后序遍历序列，才能唯一地确定一颗二叉树，如果二叉树中存在度为 1 的节点时是无法唯一地确定一棵二叉树的，这是因为我们无法判断该节点是左子树还是右子树。

[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)



![树的还原.png](https://raw.githubusercontent.com/Overmind7/images/main/img/ac050d257073f47285353d7ad412fb832326237ea85948a8b69d338171d67543-%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F.png)



- 构建新的 vector

```cpp
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if(preorder.empty() || inorder.empty()) return nullptr;
    int root_value = preorder[0];
    vector<int> n_preorder(preorder.begin() + 1, preorder.end());

    int index = 0;
    for(index; index < inorder.size(); index++){
        if(inorder[index] == root_value) break;
    }

    vector<int> l_p(n_preorder.begin(), n_preorder.begin() + index);
    vector<int> l_i(inorder.begin(), inorder.begin() + index);
    vector<int> r_p(n_preorder.begin()+index, n_preorder.end());
    vector<int> r_i(inorder.begin() + index + 1, inorder.end());

    TreeNode* root = new TreeNode(root_value);
    root->left = buildTree(l_p, l_i);
    root->right = buildTree(r_p, r_i);
    return root;
}
```

- 在 vector 原地操作



## [15. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

- 使用新的vector

```cpp
TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    if(nums.size() == 0) return nullptr;
    int max = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] > max) {
            max = nums[i];
            index = i;
        }
    }
    TreeNode* root = new TreeNode(max);

    vector<int> n_l(nums.begin(),nums.begin()+index);
    vector<int> n_r(nums.begin()+index+1,nums.end());

    root->left = constructMaximumBinaryTree(n_l);
    root->right = constructMaximumBinaryTree(n_r);
    return root;
}
```

- 在 vector 原地操作

```cpp
class Solution {
public:
    TreeNode* order(vector<int>& nums, int left, int right){
        if(right - left < 0) return nullptr;
        // 这里如果是闭区间的话，不能是 <=
        int max = 0;
        int index = left;
        for(int i = left; i <= right; i++){
            if(nums[i] > max) {
                max = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(max);
        root->left = order(nums, left, index - 1);
        root->right = order(nums, index + 1, right);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int size = nums.size()-1;

        TreeNode* root = order(nums, 0, size);
        return root;
        
    }
};
```



## [16. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

**确定终止条件：**

因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。

反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。

```cpp
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if(root1 == nullptr) return root2;
    if(root2 == nullptr) return root1;

    root1->val += root2->val;

    root1->left = mergeTrees(root1->left, root2->left);
    root1->right = mergeTrees(root1->right, root2->right);

    return root1;

}
```



## [17. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。

那么二叉树如何可以自底向上查找呢？

回溯啊，二叉树回溯的过程就是从低到上。

后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。



**如果left 和 right都不为空，说明此时root就是最近公共节点。**

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root == nullptr) return nullptr;
    if(p == root || q == root) return root;

    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);

    if(left == nullptr && right == nullptr) return nullptr;
    else if(left != nullptr && right == nullptr) return left;
    else if(left == nullptr && right != nullptr) return right;
    else return root; 
}
```



### [1123. 最深叶节点的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/)

dfs

```cpp
// 返回int储存深度，返回最深的，同时返回公共祖先节点
// 后序遍历
pair<TreeNode*, int> dfs(TreeNode* root){
    if(root == nullptr) return {nullptr, 0};

    auto left = dfs(root->left);
    auto right = dfs(root->right);

    if(left.second > right.second) return {left.first, left.second+1};
    if(left.second < right.second) return {right.first, right.second+1};
    // 左右的深度相同，则root是最近公共祖先
    return {root, left.second + 1};
}
TreeNode* lcaDeepestLeaves(TreeNode* root) {
    return dfs(root).first;
}
```

分解：先求深度，再求深度下的公共祖先。

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root){
        if(root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
    TreeNode* commonA(TreeNode* root, int curDepth, int maxDepth){
        if(root == nullptr) return nullptr;
        if(curDepth == maxDepth) return root;

        auto left = commonA(root->left, curDepth+1, maxDepth);
        auto right = commonA(root->right, curDepth+1, maxDepth);

        if(left == nullptr && right == nullptr) return nullptr;
        else if(left == nullptr && right != nullptr) return right;
        else if(left != nullptr && right == nullptr) return left;
        else return root;
    }
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        int max = maxDepth(root);
        return commonA(root, 1, max);
    }
};
```

### [235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

- 直接用二叉树搜索公共祖先的方法
- 利用二叉树的有序性质
    - 如果 root 的值大于q 和 p，则必定在root 左边，只用在 root->left 递归
    - 如果……右边
    - 如果 q，p 分列两边，根据bst的性质，q，p的最近公共祖先必定是root

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root == nullptr) return nullptr;

    if(root->val > p->val && root->val > q->val){
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        if(left) return left;
    }

    if(root->val < p->val && root->val < q->val){
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(right) return right;
    }
    return root;
}
```





## 18.二叉搜索树

### 1. 性质

**二叉搜索树（Binary Search Tree）**：也叫做二叉查找树、有序二叉树或者排序二叉树。是指一棵空树或者具有下列性质的二叉树：

- 如果任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值。
- 如果任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值。
- 任意节点的左子树、右子树均为二叉搜索树。



二叉树具有一个特性，即：**左子树的节点值 < 根节点值 < 右子树的节点值**。

根据这个特性，如果我们以中序遍历的方式遍历整个二叉搜索树时，会得到一个递增序列。

::: warning

二叉搜索树也可以为空

:::



### 2. 查找

按照二叉搜索树的定义，在进行元素查找时，我们只需要根据情况判断需要往左还是往右走。这样，每次根据情况判断都会缩小查找范围，从而提高查找效率。二叉树的查找步骤如下：

1. 如果二叉搜索树为空，则查找失败，结束查找，并返回空指针节点 `None`。
2. 如果二叉搜索树不为空，则将要查找的值 `val`与二叉搜索树根节点的值 `root.val` 进行比较：
    1. 如果 `val == root.val`，则查找成功，结束查找，返回被查找到的节点。
    2. 如果 `val < root.val`，则递归查找左子树。
    3. 如果 `val > root.val`，则递归查找右子树。



[700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

利用搜索二叉树的性质，更像是一种二分法

```cpp
TreeNode* searchBST(TreeNode* root, int val) {
    if(root == nullptr) return root;

    if(root->val == val) return root;
    else if(root->val < val) return searchBST(root->right, val);
    else return searchBST(root->left, val);
}
```



### 3. 插入

二叉搜索树的插入操作与二叉树的查找操作过程类似，具体步骤如下：

1. 如果二叉搜索树为空，则创建一个值为 `val` 的节点，并将其作为二叉搜索树的根节点。
2. 如果二叉搜索树不为空，则将待插入的值`val`与二叉搜索树根节点的值`root.val`进行比较：
    1. 如果 `val < root.val`，则递归将值为 `val` 的节点插入到左子树中。
    2. 如果 `val > root.val`，则递归将值为 `val` 的节点插入到右子树中。



- 递归

[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

```cpp
TreeNode* insertIntoBST(TreeNode* root, int val) {
    TreeNode* node = new TreeNode(val);
    if(root == nullptr) root = node;

    if(root->val > val) root->left = insertIntoBST(root->left, val);
    if(root->val < val) root->right = insertIntoBST(root->right, val);

    return root;

}
```

- 迭代

采用pre，cur指针，记录处理位置的父节点









### 4. 创建

> **二叉搜索树的创建**：根据数组序列中的元素值，建立一棵二叉搜索树。

二叉搜索树的创建操作是从空树开始，按照给定数组元素的值，依次进行二叉搜索树的插入操作，最终得到一棵二叉搜索树。具体算法步骤如下：

1. 初始化二叉搜索树为空树。
2. 遍历数组元素，将数组元素值 `nums[i]` 依次插入到二叉搜索树中。
3. 将数组中全部元素值插入到二叉搜索树中之后，返回二叉搜索树的根节点。



- 使用类似二分法，构造一个平衡的二叉搜索树

[108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

确定递归终止条件

这里定义的是左闭右闭的区间，所以当区间 left > right的时候，就是空节点了。

```cpp
class Solution {
public:
    TreeNode* dfs(vector<int> nums, int left, int right){
        if(left > right) return nullptr;
        int index = left + (right - left)/2;
        TreeNode* root = new TreeNode(nums[index]);

        root->left = dfs(nums, left, index-1);
        root->right = dfs(nums, index + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return dfs(nums, 0, nums.size() - 1);
    }
};
```



### 5. 删除

> **二叉搜索树的删除**：在二叉搜索树中删除值为 `val` 的节点。

在二叉搜索树中删除元素，首先要找到待删除节点，然后执行删除操作。根据待删除节点所在位置的不同，可以分为 3 种情况：

1. 被删除节点的左子树为空。则令其右子树代替被删除节点的位置。
2. 被删除节点的右子树为空。则令其左子树代替被删除节点的位置。
3. 被删除节点的左右子树均不为空，则根据二叉搜索树的中序遍历有序性，删除该节点时，可以使用其直接前驱（或直接后继）代替被删除节点的位置。

- **直接前驱**：在中序遍历中，节点 `p` 的直接前驱为其左子树的最右侧的叶子节点。
- **直接后继**：在中序遍历中，节点 `p` 的直接后继为其右子树的最左侧的叶子节点。



二叉搜索树的删除算法步骤如下：

1. 如果当前节点为空，则返回当前节点。
2. 如果当前节点值大于 `val`，则递归去左子树中搜索并删除，此时 `root.left` 也要跟着递归更新。
3. 如果当前节点值小于 `val`，则递归去右子树中搜索并删除，此时 `root.right` 也要跟着递归更新。
4. 如果当前节点值等于`val`，则该节点就是待删除节点。
    1. 如果当前节点的左子树为空，则删除该节点之后，则右子树代替当前节点位置，返回右子树。
    2. 如果当前节点的右子树为空，则删除该节点之后，则左子树代替当前节点位置，返回左子树。
    3. 如果当前节点的左右子树都有，则将左子树转移到右子树最左侧的叶子节点位置上，然后右子树代替当前节点位置。





> - 确定单层递归的逻辑
>
> 这里就把二叉搜索树中删除节点遇到的情况都搞清楚。
>
> 有以下五种情况：
>
> - 第一种情况：没找到删除的节点，遍历到空节点直接返回了
> - 找到删除的节点
>     - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
>     - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
>     - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
>     - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。



@slidestart [theme]

<!-- slide1 -->

![image-20230908152640853](https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230908152640853.png)





---

<!-- slide2 -->

![image-20230908152736940](https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230908152736940.png)



---

<!-- slide3 -->

![image-20230908152713135](https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230908152713135.png)



---

<!-- slide4 -->

![image-20230908152808167](https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230908152808167.png)

---

<!-- slide5 -->

![image-20230908152903795](https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230908152903795.png)

@slideend

删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。

将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。

要删除的节点（元素7）的右孩子（元素9）为新的根节点。.



```cpp
TreeNode* deleteNode(TreeNode* root, int key) {
    if(root == nullptr) return root;

    if(root->val > key) root->left = deleteNode(root->left, key);
    if(root->val < key) root->right = deleteNode(root->right, key);
    if(root->val == key){
        if(root->left == nullptr && root->right == nullptr) {
            delete root;
            return nullptr;
        }

        else if(root->left && root->right == nullptr){
            auto tmp = root;
            root = root->left;
            delete tmp;
            return root;
        }
        else if(root->right == nullptr && root->right){
            auto tmp = root;
            root = root->right;
            delete tmp;
            return root;
        }
        // 左右两边都存在
        else {
            auto tmp = root;
            auto cur = root->right;
            // while(cur->left && cur->right){
            // 最左边的节点,而不一定是最左边的叶子节点
            while(cur->left){
                cur = cur->left;
            }
            cur->left = root->left;
            root = root->right;
            delete tmp;
            return root;

        }
    }
    return root;

}
```

[450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)



#### [修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/)

<img src="https://raw.githubusercontent.com/Overmind7/images/main/img/trim2.jpg" alt="img" style="zoom:67%;" />



> 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
> 输出：[3,2,null,1]

如上例所示，如果 root->val < low 这种情况的剪枝不能直接返回nullptr

```cpp
TreeNode* trimBST(TreeNode* root, int low, int high) {
    if (root == nullptr ) return nullptr;
    if (root->val < low) {
        TreeNode* right = trimBST(root->right, low, high); 
        // 寻找符合区间[low, high]的节点
        return right;
    }
    if (root->val > high) {
        TreeNode* left = trimBST(root->left, low, high); 
        // 寻找符合区间[low, high]的节点
        return left;
    }
    root->left = trimBST(root->left, low, high); 
    // root->left接入符合条件的左孩子
    root->right = trimBST(root->right, low, high); 
    // root->right接入符合条件的右孩子
    return root;
}
```



### 6. 例子



[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/)

中序遍历，检查是否递增（递归）

```cpp
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& res){
        if(root == nullptr) return;
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);

    }
    bool isValidBST(TreeNode* root) {
        vector<int> result;
        inorder(root, result);
        if(result.size() == 1) return true;
        int pre = result[0];
        for(int i = 1; i < result.size(); i++){
            if(pre < result[i]) pre = result[i];
            else return false;
        }
        return true;
    }
};
```

中序遍历，迭代

```cpp
bool isValidBST(TreeNode* root) {
    stack<TreeNode*> stack;
    TreeNode* pre = nullptr;
    TreeNode* cur = root;
    while(cur || !stack.empty()){
        if(cur){
            stack.push(cur);
            cur = cur->left;
        }
        else{
            cur = stack.top();
            stack.pop();
            // 这里pre用指针比较，而不是记录pre的值，避免int越界
            // 但是这里当 pre 为空指针的时候，需要考虑进来，用 || 熔断
            if(pre == nullptr || pre->val < cur->val) pre = cur;
            else return false;

            cur = cur->right;
        }
    }
    return true;

}
```

可以把上面迭代写成递归的形式：

- 确定终止条件

如果是空节点 是不是二叉搜索树呢？

是的，二叉搜索树也可以为空！

```cpp
class Solution {
public:
    // 测试数据有
    long long index = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        
        bool left = isValidBST(root->left);
        
        if(root->val > index) index = root->val;
        else return false;
        
        bool right = isValidBST(root->right);
        
        return left && right;
    }
};
```

#### 二叉树中的双指针

[530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

- 直接中序遍历，得到数组再求
- 在递归中如何记录前一个节点的指针

```cpp
class Solution {
private:
int result = INT_MAX;
TreeNode* pre = NULL;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur->left);   // 左
    
    if (pre != NULL){       // 中
        result = min(result, cur->val - pre->val);
    }
    
    pre = cur; // 记录前一个
    traversal(cur->right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

- 按普通链表处理
- 统计二叉树频率之后，排序，输出

```cpp
class Solution {
public:
    bool static cmp (const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    }
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> stack;
        unordered_map<int, int> map;
        vector<int> result;

        TreeNode* cur = root;

        while( cur || !stack.empty()){
            if(cur){
                stack.push(cur);
                cur = cur->left;
            }
            else{
                cur = stack.top();
                stack.pop();

                map[cur->val]++;

                cur = cur->right;
            }
        }

        vector<pair<int, int>> vec(map.begin(), map.end());
        sort(vec.begin(), vec.end(), cmp); // 给频率排个序
        result.push_back(vec[0].first);

        for (int i = 1; i < vec.size(); i++) {
            // 取最高的放到result数组中
            if (vec[i].second == vec[0].second) result.push_back(vec[i].first);
            else break;
        }
        return result;

    }
};
```

- 利用二叉树的性质



[235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

见公共祖先，



[538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

反中序遍历，右中左，从后往前累加

```cpp
class Solution {
public:
    TreeNode* pre = nullptr;
    void reinorder(TreeNode* root){
        if(root == nullptr) return;
        TreeNode* cur = root;

        if(root->right) reinorder(root->right);

        if(!pre) pre = cur;
        else cur->val += pre->val;
        pre = cur;

        if(root->left) reinorder(root->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        reinorder(root);
        return root;
    }
};
```

