---
sidebar: auto
---



# 二叉树

## 1. 理论基础

链式储存二叉树

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

顺序储存

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220221144552.png)

> [01.树与二叉树的基础知识 | 算法通关手册 (itcharge.cn)](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)

从图中我们也可以看出节点之间的逻辑关系。

- 如果某二叉树节点（非叶子节点）的下标为 $i$，那么其左孩子节点下标为 $2∗i+1$，右孩子节点下标为 $2∗i+2$。
- 如果某二叉树节点（非根结点）的下标为$ i$，那么其根节点下标为 $(i−1)//2$。$//$ 表示整除。

对于完全二叉树（尤其是满二叉树）来说，采用顺序存储结构比较合适，它能充分利用存储空间；

而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。并且，由于顺序存储结构固有的一些缺陷，会使得二叉树的插入、删除等操作不方便，效率也比较低。

对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。



## 2. 递归遍历

**每次写递归，都按照这三要素来写**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

举例：中序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec){
        if(cur == nullptr) return;
        traversal(cur->left,vec);
        vec.push_back(cur->val);
        traversal(cur->right,vec);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```



## 3. 迭代遍历



二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
    1. 弹出栈顶元素 `node`，并访问该元素。
    2. 如果 `node` 的右子树不为空，则将 `node` 的右子树入栈。
    3. 如果 `node` 的左子树不为空，则将 `node` 的左子树入栈。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165249.png)



------------------

二叉树的中序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈。
3. 当根节点或者栈不为空时：
    1. 如果当前节点不为空，则循环遍历左子树，并不断将当前子树的根节点入栈。
    2. 如果当前节点为空，说明当前节点无左子树，则弹出栈顶元素 `node`，并访问该元素，然后尝试访问该节点的右子树。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165231.png)



--------------------

二叉树的后序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈，使用 `prev` 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕。
3. 当根节点或者栈不为空时，从当前节点开始：
    1. 如果当前节点有左子树，则不断遍历左子树，并将当前根节点压入栈中。
    2. 如果当前节点无左子树，则弹出栈顶元素 `node`。
    3. 如果栈顶元素 `node` 无右子树（即 `not node.right`）或者右子树已经访问完毕（即 `node.right == prev`），则访问该元素，然后记录前一节点，并将当前节点标记为空节点。
    4. 如果栈顶元素有右子树，则将栈顶元素重新压入栈中，继续访问栈顶元素的右子树。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165218.png)

> [02.二叉树的遍历知识 | 算法通关手册 (itcharge.cn)](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/#32-二叉树的中序遍历显式栈实现)



## 4. 层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/20220222165158.png)

二叉树的层序遍历是通过队列来实现的。具体步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 令根节点入队。
3. 当队列不为空时，求出当前队列长度 $S_i$。
4. 依次从队列中取出这 $S_i$ 个元素，并对这 $S_i$ 个元素依次进行访问。然后将其左右孩子节点入队，然后继续遍历下一层节点。
5. 当队列为空时，结束遍历。

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    vector<vector<int>> result;
    while(!que.empty()){
        int size = que.size();
        vector<int> res;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            res.push_back(tmp->val);
            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            que.pop();
        }
        result.push_back(res);
    }
    return result;
}
```

递归法：

```cpp
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth){
        // 确定参数和返回值
        // 确定终止条件
        if(cur == nullptr) return;
        // 确定单层递归条件
        // 在二维容器中新建一个空行
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth+1);
        order(cur->right, result, depth+1);
    }
    
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;

    }
};
```

[107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

和前面一样，最后翻转`vector<vector<int>> result;`

[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/)

- 使用递归，得到总的层序遍历，输出 每一行的 `back()`

```cpp
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth){
        if(cur == nullptr) return;
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result,depth+1);
        order(cur->right,result,depth+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        vector<vector<int>> tmp;
        int depth = 0;
        order(root, tmp, depth);

        vector<int> result;
        for(auto i = tmp.begin(); i != tmp.end(); i++){
            result.push_back((*i).back());
        }
        return result;
    }
};
```

- 使用迭代法，输出每一层的最后一个节点到 result 中

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();

            for(int i = 0; i < size; i++){
                TreeNode* tmp = que.front();
                if(i == size-1) result.push_back(tmp->val);
                if(tmp->left) que.push(tmp->left);
                if(tmp->right) que.push(tmp->right);
                que.pop();
            }
        }
        return result;
    }
};
```

[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

对每一层求平均值

```cpp
vector<double> averageOfLevels(TreeNode* root) {
    vector<double> result;
    // vector<vector<int>> vec;
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        double cnt = 0;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();
            cnt += tmp->val;
            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        result.push_back(double(cnt/size));
    }
    return result;
}
```

[429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

- 递归

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    void order(Node* cur, vector<vector<int>>& result, int depth){
        if(cur == nullptr) return;
        if(result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        for(auto i : cur->children){
            order(i,result,depth+1);
        }
    }
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

- 迭代

```cpp
vector<vector<int>> levelOrder(Node* root) {
    vector<vector<int>> result;
    queue<Node*> que;
    if(root != nullptr)que.push(root);
    while(!que.empty()){
        int size = que.size();
        vector<int> vec;
        for(int i = 0; i < size; i++){
            Node* tmp = que.front();
            que.pop();
            vec.push_back(tmp->val);
            for(auto i:tmp->children){
                if(i) que.push(i);
            }
            //for (int i = 0; i < node->children.size(); i++) { // 将节点孩子加入队列
            //        if (node->children[i]) que.push(node->children[i]);
            //}
        }
        
        result.push_back(vec);

    }
    return result;
}
```

[515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```cpp
vector<int> largestValues(TreeNode* root) {
    vector<int> result;
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        int index = INT_MIN;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();
            // if(tmp->val > index) index = tmp->val;
            index = index > tmp->val ? index : tmp->val;

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        result.push_back(index);
    }
    return result;
}
```

[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```cpp
Node* connect(Node* root) {
    if(root == nullptr || root->left == nullptr) return root;
    root->left->next = root->right;
    if(root->next != nullptr){
        root->right->next = root->next->left;
    }
    connect(root->left);
    connect(root->right);
    return root;
}
```



```cpp
Node* connect(Node* root) {
    queue<Node*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        Node* pre;
        Node* cur;
        for(int i = 0; i < size; i++){
            if(i == 0){
                pre = que.front();
                que.pop();
                cur = pre;
            }
            else{
                cur = que.front();
                que.pop();
                pre->next = cur;
                pre = pre->next;

            }
            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
    }
    return root;
}
```

[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

```cpp
Node* connect(Node* root) {
    queue<Node*> que;
    if(root != nullptr) que.push(root);
    while(!que.empty()){
        int size = que.size();
        Node* pre = nullptr;
        Node* cur = nullptr;
        for(int i = 0; i < size; i++){
            if(i == 0){
                pre = que.front();
                que.pop();
                cur = pre;
            }
            else{
                cur = que.front();
                que.pop();
                pre->next = cur;
                pre = pre->next;;
            }

            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
    }
    return root;
}
```

> 怎么用递归写呢？



### [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

深度优先搜索

```cpp
int maxDepth(TreeNode* root) {
    if( root == nullptr) return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

广度优先搜索

```cpp
int maxDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);

    int cnt = 0;
    while(!que.empty()){
        int size = que.size();

        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
        cnt++;
    }
    return cnt;

}
```

### [559. N 叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if(root == nullptr) return 0;
        int maxChilderndepth = 0;
        for(auto i : root->children){
            int childDepth = maxDepth(i);
            maxChilderndepth = max(maxChilderndepth,childDepth);
        }
        return maxChilderndepth + 1;
    }
};
```



### [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

深度优先搜索

```cpp
int minDepth(TreeNode* root) {
    if(root == nullptr) return 0;
    if(root->left == nullptr && root->right == nullptr) return 1;

    int min_depth = INT_MAX;
    if( root->left != nullptr){
        min_depth = min(minDepth(root->left),min_depth);
    }
    if(root->right != nullptr){
        min_depth = min(minDepth(root->right),min_depth);
    }
    return min_depth+1;
}
```

广度优先搜索

**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

```cpp
int minDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    int depth = 0;
    while(!que.empty()){
        int size = que.size();
        depth++;
        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            if(tmp->left == nullptr && tmp->right==nullptr) return depth;               
        }
    }
    return depth;
}
```





## [6. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr) return root;
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    invertTree(root->right);        // 右
    return root;
}
```



## [7. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

不是层序遍历

```cpp
bool compare(TreeNode* left, TreeNode* right) {
    // 首先排除空节点的情况
    if (left == NULL && right != NULL) return false;
    else if (left != NULL && right == NULL) return false;
    else if (left == NULL && right == NULL) return true;
    // 排除了空节点，再排除数值不相同的情况
    else if (left->val != right->val) return false;

    // 此时就是：左右节点都不为空，且数值相同的情况
    // 此时才做递归，做下一层的判断
    bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
    bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
    bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
    return isSame;

}
bool isSymmetric(TreeNode* root) {
    if (root == NULL) return true;
    return compare(root->left, root->right);
}
```



### [相同的树 - 力扣](https://leetcode.cn/problems/same-tree/)

```cpp
bool isSameTree(TreeNode* left, TreeNode* right){
    if(left == nullptr && right != nullptr) return false;
    else if(left != nullptr && right == nullptr) return false;
    else if(left == nullptr && right == nullptr) return true;
    else if(left->val != right->val) return false;
    bool a = isSameTree(left->left,right->left);
    bool b = isSameTree(left->right,right->right);
    return a&&b;
}
```



### [另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)





## [8. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

- 按照普通二叉树遍历，时间复杂度为 n

```cpp
int countNodes(TreeNode* root) {
    if(root == nullptr) return 0;

    int left = countNodes(root->left);
    int right = countNodes(root->right);
    int sum = left + right + 1;
    return sum;
}
```

- 利用完全二叉树的性质

    - 时间复杂度：O(log n × log n)

    - 空间复杂度：O(log n)

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            // 2^n - 1
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

后序排序

```cpp
int rightTreeNum = countNodes(root->right);     // 右
int result = leftTreeNum + rightTreeNum + 1;    // 中
return result;
```



## [9. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

二叉树的高度：





二叉树的深度：

> https://leetcode.cn/problems/balanced-binary-tree/solutions/8737/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/



![Picture1.png](https://raw.githubusercontent.com/Overmind7/images/main/img/1603024695-GYNvjf-Picture1.png)

**使用 -1 标记，剪枝已经不符合条件的子树**

```cpp
class Solution {
public:
    int recur(TreeNode* root){
        if(root == nullptr) return 0;
        
        int left = recur(root->left);
        if(left == -1) return -1;
        int right = recur(root->right);
        if(right == -1) return -1;
        
        int relative = abs(left - right);

        if(relative < 2) return max(left,right)+1;
        else return -1;
    }
    bool isBalanced(TreeNode* root) {
        return recur(root) != -1;
    }
};
```

单层递归的逻辑

如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。



## [10. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)



给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://raw.githubusercontent.com/Overmind7/images/main/img/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

- 回溯

> https://leetcode.cn/problems/binary-tree-paths/solutions/400434/257-er-cha-shu-de-suo-you-lu-jing-tu-wen-jie-xi-by/



```cpp
class Solution {
public:
    void preorder(TreeNode* cur, string path, vector<string>& result){
        if(cur == nullptr) return;

        if(cur->left == nullptr && cur->right == nullptr){
            result.push_back( path + to_string(cur->val));
            // "->" 放在这里会导致第一个路径也有这个，所以放在后面
            return;
        } 

        preorder(cur->left, path + to_string(cur->val) + "->", result);
        preorder(cur->right, path + to_string(cur->val) + "->", result);

    }
    vector<string> binaryTreePaths(TreeNode* root) {
        // 使用前序遍历
        vector<string> result;
        preorder(root, "", result);
        return result;
    }
};
```

为什么这里用了回溯？

preorder 的参数 path 不带引用和指针，是复制过来的，对上层没有影响

- 递归：

假设 root 的左右子树的 path 已经求出来了

```cpp
vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> result;
    if(root == nullptr) return result;
    if(root->left == nullptr && root->right == nullptr) {
        result.push_back(to_string(root->val));
    }

    for( auto path : binaryTreePaths(root->left)){
        result.push_back(to_string(root->val) + "->" + path);
    }
    for( auto path : binaryTreePaths(root->right)){
        result.push_back(to_string(root->val) + "->" + path);
    }
    return result;
}
```



- 迭代

```cpp
vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> result;
    queue<TreeNode*> que;
    queue<string> path;
    if(root != nullptr){
        que.push(root);
        path.push(to_string(root->val));
    }
    while(!que.empty()){
        TreeNode* cur = que.front();
        string cur_path = path.front();
        que.pop();
        path.pop();

        if(cur->left == nullptr && cur->right == nullptr){
            result.push_back(cur_path);
        }
        if(cur->left){
            que.push(cur->left);
            path.push(cur_path + "->" + to_string(cur->left->val));
        }
        if(cur->right){
            que.push(cur->right);
            path.push(cur_path + "->" + to_string(cur->right->val));

        }
    }
    return result;
}
```



## [11. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

![图二](https://raw.githubusercontent.com/Overmind7/images/main/img/20220902165805.png)

如何判断左叶子，不是二叉树的左侧节点

```cpp
class Solution {
public:
    void order(TreeNode* cur, int& cnt){
        if(cur == nullptr) return;
        // 如果判断左叶子
        if(cur->left && cur->left->left == nullptr && cur->left->right == nullptr){
            cnt += cur->left->val;
        }
        order(cur->left, cnt);
        order(cur->right, cnt);
        // cnt = order(cur->left, cnt) + order(cur->right, cnt);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        int cnt = 0;
        order(root, cnt);
        return cnt;
    }
};
```

更简单的写法

```cpp
int sumOfLeftLeaves(TreeNode* cur){
    if(cur == nullptr) return 0;
    // 如果判断左叶子
    int left = 0;
    if(cur->left && cur->left->left == nullptr && cur->left->right == nullptr){
        left =cur->left->val;
    }
    return left + sumOfLeftLeaves(cur->left) + sumOfLeftLeaves(cur->right);
}
```

## [12. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

- 层序遍历

```cpp
int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr) que.push(root);
    int result;
    while(!que.empty()){
        int size = que.size();

        for(int i = 0; i < size; i++){
            TreeNode* tmp = que.front();
            if(i == 0) result = tmp->val;

            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
        }
    }
    return result;

}
```

- 迭代



## [13. 路径总和](https://leetcode.cn/problems/path-sum/)

- 递归

```cpp
bool hasPathSum(TreeNode* root, int targetSum) {
    if(root == nullptr) return false;

    if(root->left == nullptr && root->right == nullptr && root->val == targetSum){
        return true;
    }

    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum- root->val);



}
```

- 迭代（与 二叉树所有路径类似）
    - bfs，层序遍历

```cpp
bool hasPathSum(TreeNode* root, int targetSum) {
    // 层序遍历
    queue<TreeNode*> que;
    queue<int> cnt;
    if(root != nullptr){
        que.push(root);
        cnt.push(root->val);
    }
    while(!que.empty()){
        TreeNode* tmp_node = que.front();
        int tmp_val = cnt.front();
        que.pop();
        cnt.pop();

        if(tmp_node->left == nullptr && tmp_node->right == nullptr){
            if(tmp_val == targetSum) return true;
        }
        if(tmp_node->left){
            que.push(tmp_node->left);
            cnt.push(tmp_val + tmp_node->left->val);
        }
        if(tmp_node->right){
            que.push(tmp_node->right);
            cnt.push(tmp_val + tmp_node->right->val);
        }
    }
    return false;
}
```

::: tip 确定递归函数的参数和返回类型

参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

:::

[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/)

> 把当前的结点（叫他N1吧）加入数组中，然后去遍历他的左孩子，左孩子的所有孩子结点都遍历完之后，又回到了N1，
>
> 如果你这时候pop了，相当于把N1这个结点去掉了，而你这个时候还没有递归调用N1的右孩子结点，当你递归N1的右节点，数组里N1的值就已经被你pop了，就这出现问题了呀。
>
> 只有当递归调用完N1的左右孩子才能pop当前这个N1的结点，这就是为什么只需要一次删除，况且你一个N1节点只加入了一次，当然是pop一次了。

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(TreeNode* root, int targetSum){
        if(root == nullptr) return;

        targetSum -= root->val;
        path.push_back(root->val);

        if(!root->left && !root->right && targetSum == 0){
            res.push_back(path);
        }

        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root,targetSum);
        return res;

    }
};
```



## [14.二叉树的还原知识](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/04.Binary-Tree-Reduction/)

![树的还原.png](https://raw.githubusercontent.com/Overmind7/images/main/img/ac050d257073f47285353d7ad412fb832326237ea85948a8b69d338171d67543-%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F.png)