import{_ as n,o as s,c as a,e as p}from"./app-04b0d2b0.js";const t={},e=p(`<h1 id="虚函数与动态多态性" tabindex="-1"><a class="header-anchor" href="#虚函数与动态多态性" aria-hidden="true">#</a> 虚函数与动态多态性</h1><h2 id="利用虚函数实现动态多态性" tabindex="-1"><a class="header-anchor" href="#利用虚函数实现动态多态性" aria-hidden="true">#</a> 利用虚函数实现动态多态性</h2><h3 id="虚函数" tabindex="-1"><a class="header-anchor" href="#虚函数" aria-hidden="true">#</a> 虚函数</h3><h4 id="引入" tabindex="-1"><a class="header-anchor" href="#引入" aria-hidden="true">#</a> 引入</h4><p><strong>回顾</strong></p><p>在同一类中不能定义两个名字相同，参数个数和类型都相同的函数（重复定义）。</p><p>在类的继承结构中，在不同的层次中可以出现名字相同，参数个数类型都相同而功能不同的函数。</p><p>这是合法的，编译系统按照&#39;同名覆盖&#39;的原则决定调用对象。</p><p>如果想要调用基类的同名函数，需要用 基类名加&#39;<strong>域运算符</strong>&#39; 区分同名函数，例</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>cy1<span class="token punctuation">.</span><span class="token class-name">Circle</span><span class="token double-colon punctuation">::</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于 <strong>同名数据成员</strong>：</p><p>⚠️当派生类中的成员变量和基类中同名，那么与函数同名一样，基类中的同名变量会被隐藏。</p><ul><li>也就是<strong>通过派生类对象无法访问基类的同名变量</strong></li></ul><p><strong>能否用同一个调用形式来调用派生类和基类的同名函数？？</strong></p><p>在程序中不是通过对象名去调用不同派生层次的同名函数</p><p>而是通过 <strong>指针 调用</strong>！！</p><p>调用前临时将指针变量 pt 赋予不同的值</p><hr><h4 id="虚函数概念" tabindex="-1"><a class="header-anchor" href="#虚函数概念" aria-hidden="true">#</a> 虚函数概念</h4><p><mark>基类声明函数是虚拟的</mark>，并不是实际存在的函数，然后在派生类中才正式定义此函数</p><p>在程序运行期间，用指针指向某一派生类对象</p><p>这样就能调用指针指向的派生类对象中的函数，而不会调用其他派生类中的函数</p><h4 id="虚函数的作用" tabindex="-1"><a class="header-anchor" href="#虚函数的作用" aria-hidden="true">#</a> 虚函数的作用</h4><p>允许在派生类中重新定义与基类同名的函数，</p><p>并且可以通过基类指针或引用来访问基类和派生类中的同名函数</p><div class="custom-container tip"><p class="custom-container-title">类族</p><p>如果基类有多个派生类，每个派生类又产生新的派生类，形成了同一基类的类族</p></div><h4 id="举例" tabindex="-1"><a class="header-anchor" href="#举例" aria-hidden="true">#</a> 举例</h4><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">student</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">student</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>string nam<span class="token punctuation">,</span><span class="token keyword">float</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//声明构造函数</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//声明输出函数</span>
  <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token comment">//受保护的成员，派生类可以访问</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
    string name<span class="token punctuation">;</span>
    <span class="token keyword">float</span> score<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

student<span class="token double-colon punctuation">::</span><span class="token function">student</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>string nam<span class="token punctuation">,</span><span class="token keyword">float</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
  num <span class="token operator">=</span> n<span class="token punctuation">;</span>
  name <span class="token operator">=</span> nam<span class="token punctuation">;</span>
  score <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> student<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;num: &quot;</span><span class="token operator">&lt;&lt;</span>num
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\\nname: &quot;</span><span class="token operator">&lt;&lt;</span>name
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\\nscore: &quot;</span><span class="token operator">&lt;&lt;</span>score
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\\n\\n&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">graduate</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">student</span></span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">graduate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span>string<span class="token punctuation">,</span><span class="token keyword">float</span><span class="token punctuation">,</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//声明构造函数</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//声明输出函数，与基类的输出函数同名</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">float</span> wage<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

graduate<span class="token double-colon punctuation">::</span><span class="token function">graduate</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>string nam<span class="token punctuation">,</span><span class="token keyword">float</span> s<span class="token punctuation">,</span><span class="token keyword">float</span> w<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">student</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>nam<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">wage</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">void</span> graduate<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;num: &quot;</span><span class="token operator">&lt;&lt;</span>num
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\\nname: &quot;</span><span class="token operator">&lt;&lt;</span>name
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\\nscore: &quot;</span><span class="token operator">&lt;&lt;</span>score
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\\nwage: &quot;</span><span class="token operator">&lt;&lt;</span>wage<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  student <span class="token function">stud1</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span><span class="token string">&quot;LI&quot;</span><span class="token punctuation">,</span><span class="token number">33.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  graduate <span class="token function">grad1</span><span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token string">&quot;gan&quot;</span><span class="token punctuation">,</span><span class="token number">12.2</span><span class="token punctuation">,</span><span class="token number">1222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  student <span class="token operator">*</span>pt <span class="token operator">=</span> <span class="token operator">&amp;</span>stud1<span class="token punctuation">;</span>
  pt<span class="token operator">-&gt;</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  pt <span class="token operator">=</span> <span class="token operator">&amp;</span>grad1<span class="token punctuation">;</span>
  pt<span class="token operator">-&gt;</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 运行结果：没有出现 wage 的数据！！！</p><p>​ 程序分析：</p><p>​ 用指向父类的指针输出父类数据后，将指针指向派生类，试图输出 grad1 的全部数据成员</p><p>​ 但是只输出类 grad1 中基类的数据成员</p><p>​ 说明没有调用 grad1 中的 display 函数（基类指针指向的是派生类对象中的基类部分）</p><p>​</p><div class="custom-container tip"><p class="custom-container-title">其他方法：（不使用虚函数）</p><p>1、通过对象名调用 display 函数，例 <code>grad1.display()</code></p><p>按照同名覆盖的方法，如果要调用基类的 <code>display()</code></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>grad1<span class="token punctuation">.</span>sutdent<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、定义一个指向派生类的指针 p，再有 <code>p-&gt;display()</code></p><p>3、定义指向基类的指针 p 指向派生类，调用 <code>p-&gt;display()</code></p><p>则只能调用其中的继承的基类的 <code>display()</code> 函数，而不是派生类的 <code>display()</code></p><p>这些方法都不方便</p><blockquote><p>如果派生类中改名为如 <code>dispaly1</code>，也不行，因为指向的派生类中的基类没有此成员函数</p></blockquote></div><p>​</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>​ 问题：如何用同一种方式去调用同一类族中不同类的所有同名函数？？</p><p>​ 解决方法：使用虚函数</p></div><p>​ 在基类 student 的 display 函数声明前加上关键字 virtual</p><p>​ virtual void dispaly()</p><p>​ 用同一种调用形式 pt-&gt;display()，且 pt 是同一个基类的指针，调用同一类族的不同虚函数</p><p>​ 这些就实现了对同一消息不同对象有不同的响应方式（多态性）</p><p>4、虚函数的作用</p><p>​ 1、原理</p><p>​ 基类中的函数被声明为虚函数，在声明派生类时被重载</p><p>​ 派生类的同名函数取代了基类中的虚函数</p><p>​ 因此在使用基类指针指向派生类对象后，调用 display 函数时调用了派生类的 display 函数</p><p>​ 注意⚠️：只有通过 virtual 声明了函数为虚函数后才行，试图通过基类指针调用派生类的非虚函数是不行的</p><p>​ 2、作用</p><p>​ 其他方式的缺点</p><p>​ 类的继承目的是保留基类的特性，但是从基类继承的某些成员函数无法满足新的需要</p><p>​ 可以使函数名字不同，如果派生类过多也不方便</p><p>​ 如果名字相同会出现同名覆盖</p><p>​ 虚函数</p><p>​ 把基类的某个成员函数声明为虚函数之后，允许在其派生类中对函数重新定义，赋予新的功能</p><p>​ 并且可以通过指向基类的指针指向同一类族中不同类的对象，从而调用其中的同名函数</p><p>​</p><div class="custom-container tip"><p class="custom-container-title">由虚函数实现的多态性实质就是</p><p>​ 同一类族中不同类的对象，对同一函数调用做出不同的响应</p></div><p>5、虚函数使用方法</p><p>​ 1、在基类中用 virtual 声明成员函数为虚函数，在类外定义虚函数时，不必再加 virtual</p><p>​ 2、在派生类中重新定义此函数</p><p>​ 函数名、函数类型、函数参数个数和类型必须与基类的虚函数相同</p><p>​ 根据派生类的需要重新定义函数体</p><p>​ 当一个成员函数被声明为虚函数后</p><p>​ 派生类中的同名函数都自动成为虚函数</p><p>​ 派生类中重新声明该虚函数时，可加可不加 virtual（为了易读性，最好每一层都加）</p><p>​ 如果派生类中没有对基类的虚函数重新定义：</p><p>​ 派生类简单地继承&#39;直接基类的虚函数&#39;</p><p>​ 3、定义一个指向基类的指针变量，并使它指向同一类族中需要调用该函数的对象</p><p>​ 4、通过该指针变量调用此虚函数，调用的是指针变量指向对象的同名虚函数</p><p>​ 5、在什么情况下声明虚函数？？</p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><ol><li>只能用 virtual 声明类的成员函数，而不能声明类外的普通函数为虚函数</li><li>一个成员函数被声明为虚函数后，在同一类族中的类不能再定义一个 非virtual 的但与该虚函数具有相同参数和函数返回值类型的同名函数类</li></ol></div><p>​ 2、考虑一下几点</p><p>​ 1、看成员函数所在的类是否会作为基类，在类继承后有无可能被更改功能</p><p>​ 2、如果成员函数在类被继承后功能无需修改，或者派生类用不到该函数（不要把基类所有函数都声明为虚函数）</p><p>​ 3、考虑对成员函数的调用是通过对象名、基类指针 还是 引用 去访问</p><p>​ 如果通过 基类指针 或者 引用访问的，应当声明为虚函数</p><p>​ 4、有时定义虚函数时并不定义函数体（纯虚函数）</p><p>6、总结</p><p>​ 通过虚函数与指向基类对象的指针变量的配合使用，就能实现动态的多态性</p><p>​ 如果想调用同一类族中不同类的同名函数，只要现用基类指针指向该类对象即可</p><p>​ 如果指针先后指向同一类族中不同类的对象，就能不断地调用指向对象中的同名函数</p><p>​ 如果在基类中定义的&#39;非虚函数&#39;在派生类中重新定义</p><p>​ 如果用&#39;基类指针&#39;调用该成员函数，则会调用对象中基类部分的成员函数</p><p>​ 如果用&#39;派生类指针&#39;调用该成员函数，系统会调用派生类对象中的成员函数</p><p>​ 这使用的是不同类型的指针，而不是多态性！！</p><p>​ 函数重载：&#39;横向重载&#39;同一层次上的同名函数，函数首部不同</p><p>​ 虚函数：&#39;纵向重载&#39;不同派生层次上的同名函数，虚函数函数首部相同！</p><div class="custom-container tip"><p class="custom-container-title">使用虚函数会有空间开销！！</p><p>当一个类带有虚函数时，编译系统会为该类增加一个 <mark>虚函数表 VFT</mark>，是一个指针数组</p><ul><li>（用sizeof可以知道带虚函数的类字节数更多），</li></ul><p>存放每个虚函数的入口地址</p><p>系统在进行动态关联时的时间开销是很少的，因此多态性是高效的</p></div><h2 id="静态关联与动态关联" tabindex="-1"><a class="header-anchor" href="#静态关联与动态关联" aria-hidden="true">#</a> 静态关联与动态关联</h2><p><strong>关联：</strong></p><p>​ 确定调用的具体对象的过程称为&#39;关联&#39; binding（联编、束定、编联）</p><p><strong>静态关联</strong>：</p><p>​ 函数重载和通过对象名调用的虚函数，在编译时就可以确定其调用的虚函数属于哪个类，这种过程被称为&#39;静态关联&#39; （static binding）</p><p>​ 例如用 inline 声明的函数</p><p>​ 由于是在运行前进行关联的，又称为&#39;早期关联&#39;（early binding）</p><p><strong>动态关联</strong>：</p><p>​ 定义基类指针指向派生类并调用其中的虚函数时，编译系统只做静态的语法检查，无法确定 <code>pt-&gt;dispaly()</code> 调用的是哪个对象</p><p>​ 因此在运行阶段处理，在运行阶段把虚函数和类对象绑定的过程称为&#39;动态关联&#39;（dynamic binding）</p><p>​ 动态的多态性，运行阶段的多态性</p><p>​ 由于是在编译之后的运行阶段进行的，因此也被称为&#39;滞后关联&#39;late binding</p><p>​ 动态联编的条件：</p><p>​ 1、被调用的成员函数是虚函数</p><p>​ 2、用指针或者引用调用虚函数</p>`,103),o=[e];function c(l,i){return s(),a("div",null,o)}const r=n(t,[["render",c],["__file","虚函数与动态多态性.html.vue"]]);export{r as default};
