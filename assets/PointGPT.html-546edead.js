import{_ as i,r,o as l,c as o,a as s,d as t,b as e,e as n}from"./app-04b0d2b0.js";const p={},m=s("h1",{id:"pointgpt",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#pointgpt","aria-hidden":"true"},"#"),t(" PointGPT")],-1),h={href:"https://paperswithcode.com/paper/pointgpt-auto-regressively-generative-pre",target:"_blank",rel:"noopener noreferrer"},c={href:"https://github.com/CGuangyan-BIT/PointGPT",target:"_blank",rel:"noopener noreferrer"},g=s("p",null,[s("img",{src:"https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826134804183.png",alt:"image-20230826134804183"})],-1),d=n('<p>一种将GPT概念扩展到点云的方法，在多个3D点云下有任务中（点云分类，part分割等）上实现了最先进的性能。</p><p><img src="https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826135000020.png" alt="Fig.1"></p><h2 id="pointgpt-的整体架构" tabindex="-1"><a class="header-anchor" href="#pointgpt-的整体架构" aria-hidden="true">#</a> PointGPT 的整体架构</h2><p><img src="https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826135145171.png" alt="Fig.2"></p><blockquote><p>Fig.2. Overall architecture of our PointGPT. (a) The input point cloud is divided into multiple point patches, which are then sorted and arranged in an ordered sequence. (b) An extractor-generator based transformer decoder is employed along with a dual masking strategy for the auto-regressively prediction of the point patches. In this example, the additional mask of the dual masking strategy is applied to the same group of random tokens for better illustration purposes.</p></blockquote><p>(a) 将输入点云分为多个点patches，然后将这些点patches按顺序排序和排列。 (b) 采用基于提取器-生成器的变换器解码器以及用于点patches的自回归预测的双掩蔽策略。在此示例中，为了更好地说明目的，将双重掩码策略的附加掩码应用于同一组随机token。</p><ol><li>点云序列模块（Point Cloud Sequencer Module）：这个模块用于构建点块的有序序列。它将点云分割成不规则的点块，并按照 Morton 排序将它们排列起来，形成一个有序序列。</li><li>提取器（Extractor）：这是一个用于学习潜在表示的模块。有序的点块序列被输入到提取器中，通过自回归的方式学习点块的潜在表示。提取器的目标是从前面的点块中预测下一个点块。</li><li>生成器（Generator）：这是一个用于自回归生成点块的模块。在预训练阶段，生成器根据前面的点块生成下一个点块，以自回归的方式逐步生成点块序列。在预训练结束后，生成器被丢弃，不再使用。</li><li>预训练后的阶段（Post-Pre-training Stage）：在预训练阶段结束后，生成器被舍弃，而提取器则利用学习到的潜在表示进行下游任务。此时，不再使用双重掩码策略</li></ol><h2 id="point-cloud-sequencer" tabindex="-1"><a class="header-anchor" href="#point-cloud-sequencer" aria-hidden="true">#</a> Point Cloud Sequencer</h2><p>在点云领域，与自然语言处理（NLP）领域不同，点云缺乏预定义的词汇表，并且点云是一种稀疏结构，具有无序性的特点。为了克服这些挑战并获得一个有序的点云序列，其中每个组成单元捕捉到丰富的几何信息，论文中采用了一个三阶段的过程，包括点块划分、排序和嵌入。</p><ul><li>点块划分（Point Patch Partitioning）：该阶段将点云划分为不规则的点块。通过将点云分割成块状的子集，可以将点云的结构分解成更小的部分，以便更好地进行处理。</li><li>排序（Sorting）：划分的点块按照 Morton 排序进行排序。Morton 排序是一种用于多维数据的排序方法，通过将多维数据转换成一维的比特串，实现了对多维数据的排序。通过 Morton 排序，点块的顺序得到了定义，形成了有序的点块序列。</li><li>嵌入（Embedding）：排序后的点块序列被嵌入到模型中，用于后续的预训练和任务学习。嵌入可以将点块的几何信息转化为模型能够理解和处理的向量表示。</li></ul><p>通过这个三阶段的过程，点云被划分为有序的点块序列，并经过嵌入转换为模型可处理的表示形式。这样做的目的是克服点云领域缺乏预定义词汇表和无序性的问题，为后续的预训练和任务学习提供有序的输入。</p><h3 id="点云序列" tabindex="-1"><a class="header-anchor" href="#点云序列" aria-hidden="true">#</a> 点云序列</h3><p>PointGPT 的预训练流程包括使用点云序列模块构建有序的点块序列，提取器学习点块的潜在表示，生成器自回归生成点块序列。在预训练后阶段，生成器被舍弃，提取器利用学习到的表示进行下游任务。这个流程旨在通过自回归生成任务来学习点云数据的特征表示，并为后续任务提供更好的表示能力。</p><h3 id="点块分割" tabindex="-1"><a class="header-anchor" href="#点块分割" aria-hidden="true">#</a> 点块分割</h3><p>考虑到点云的固有稀疏性和无序性，输入点云通过最远点采样（FPS）和K近邻（KNN）算法处理，以获取中心点和点块。给定一个包含M个点的点云X，我们使用FPS初始采样n个中心点C。然后，利用KNN算法从X中选择k个最近的点构建n个点块P。</p>',15),u={class:"custom-container tip"},P=s("p",{class:"custom-container-title"},"TIP",-1),_=s("p",null,"稀疏数据中的均匀采样方法",-1),f={href:"https://blog.csdn.net/weixin_60737527/article/details/127432708",target:"_blank",rel:"noopener noreferrer"},v=s("h3",{id:"排序",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#排序","aria-hidden":"true"},"#"),t(" 排序")],-1),b=s("p",null,"为了解决点云的固有无序性，获得的点块根据它们的中心点被组织成一个连贯的序列。具体而言，使用Morton编码[34]将中心点的坐标编码到一维空间中，然后进行排序以确定这些中心点的顺序O。然后，将点块按照相同的顺序排列。",-1),y={class:"custom-container tip"},x=s("p",{class:"custom-container-title"},"TIP",-1),k=s("p",null,"莫顿码是将多维数据转化为一维数据的编码。 莫顿编码定义了一条 Z 形的空间填充曲线",-1),T=s("p",null,"类似（希尔伯特曲线）",-1),w={href:"https://blog.csdn.net/cheche012345/article/details/127729403",target:"_blank",rel:"noopener noreferrer"},L=n('<h3 id="嵌入" tabindex="-1"><a class="header-anchor" href="#嵌入" aria-hidden="true">#</a> 嵌入</h3><p>在 PointGPT 中，采用了嵌入（Embedding）步骤来提取每个点块的丰富几何信息。与论文中引用的 Point-MAE 和 PointNet 方法类似，这里使用了 PointNet 网络来进行几何信息的提取。</p><p>具体而言，对于每个点块，使用 PointNet 网络对其进行处理，以提取其中的几何信息。PointNet 是一种常用的点云处理网络，能够对点云数据进行特征提取和学习。通过应用 PointNet 网络，可以从每个点块中提取丰富的几何特征。</p><p>为了促进训练的收敛性，对每个点的坐标进行了归一化处理，相对于其所在点块的中心点进行归一化。这样做可以减小数据的尺度差异，帮助模型更好地进行训练。在嵌入步骤中，使用 PointNet 网络对每个点块进行处理，提取其中的几何信息，并对点的坐标进行归一化处理，以促进训练的收敛性。</p><h2 id="transformer-decoder-with-a-dual-masking-strategy" tabindex="-1"><a class="header-anchor" href="#transformer-decoder-with-a-dual-masking-strategy" aria-hidden="true">#</a> Transformer Decoder with a Dual Masking Strategy</h2><p>论文中提到，将 GPT 直接应用到点云数据的方法是利用基本的 Transformer 解码器来自回归地预测点块，并对所有预训练参数进行微调以进行下游任务。然而，由于点云数据的信息密度有限以及生成和下游任务之间存在差距，这种方法在低级语义方面存在问题。</p><p>为了解决这个问题，论文提出了一种双重掩码策略，以促进对点云的全面理解。这个策略能够帮助模型更好地处理点云数据，提高语义的表达能力。</p><p>此外，论文还引入了提取器-生成器 Transformer 架构，其中生成器更专注于生成任务，并在预训练后被丢弃，从而增强了提取器学习到的潜在表示的语义水平。这种架构设计使得提取器能够更好地学习点云的语义信息，提高模型的表示能力。</p><p>为了应对点云数据的低级语义和生成任务与下游任务之间的差距，论文提出了<strong>双重掩码策略</strong>和提取器-生成器 Transformer 架构。这些方法能够提高模型对点云数据的理解能力，并增强潜在表示的语义水平。</p><h3 id="dual-masking-strategy" tabindex="-1"><a class="header-anchor" href="#dual-masking-strategy" aria-hidden="true">#</a> Dual masking strategy?????</h3><p>The vanilla masking strategy in the transformer decoder enables each token to receive information from all the preceding point tokens. To further encourage the learning of useful representations, the dual masking strategy is proposed, which <strong>additionally masks a proportion of the attending preceding tokens of each token during pre-training</strong>. The resulting dual mask M d is illustrated in Fig. 2(b),</p><p>双重屏蔽策略，该策略在预训练期间另外屏蔽了每个标记的一部分先前标记。得到的双掩码M d 如图2（b）所示</p><p><img src="https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826144630599.png" alt="image-20230826144630599"></p><h3 id="extractor-generator" tabindex="-1"><a class="header-anchor" href="#extractor-generator" aria-hidden="true">#</a> Extractor-generator</h3><p><strong>Extractor</strong></p><ul><li>提取器完全由 Transformer 解码器块组成，并采用双重掩码策略，得到潜在表示 T。在这里，每个点的令牌只与前面未被掩码的令牌相互关联。</li><li>考虑到点块是用归一化坐标表示的，并且全局结构对于点云的理解至关重要，论文中采用正弦位置编码（Sinusoidal Positional Encodings）将排序后的中心点的坐标映射到绝对位置编码（Absolute Positional Encoding）。</li><li>在每个 Transformer 块中添加位置编码，以提供位置信息和整合全局结构信息。</li></ul><p><strong>Generator</strong></p><ul><li>生成器的架构与提取器类似，但包含较少的 Transformer 块。它以提取的令牌 T 作为输入，并生成用于后续预测头的点令牌 Tg。</li><li>然而，由于中心点采样过程可能会影响点块的顺序，这在预测后续点块时会引入不确定性。这使得模型难以有效地学习有意义的点云表示。 <ul><li>为了解决这个问题，在生成器中提供了相对于后续点块的方向信息（RDP， relative direction prompts ），作为提示而不暴露被掩码的点块的位置和整体点云对象的形状。</li></ul></li></ul><p><strong>Prediction head</strong></p><p>预测头用于在坐标空间中预测后续的点块。它由一个两层的多层感知机（MLP）组成，包含两个全连接（FC）层和修正线性单元（ReLU）激活函数。预测头将令牌 Tg 投影到向量空间，其中输出通道的数量等于一个点块中的坐标总数。然后，这些向量被重新组织成预测的点块 。</p><h2 id="generation-target" tabindex="-1"><a class="header-anchor" href="#generation-target" aria-hidden="true">#</a> Generation Target</h2><p>在每个点patch的生成目标是预测后续点patch内点的坐标。</p>',22),G=s("p",null,[t("给定预测的点patch "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"P"),s("mrow",null,[s("mi",null,"p"),s("mi",null,"d")])])]),s("annotation",{encoding:"application/x-tex"},"P_{pd}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9694em","vertical-align":"-0.2861em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"p"),s("span",{class:"mord mathnormal mtight"},"d")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2861em"}},[s("span")])])])])])])])]),t(" 和与排序后的点patch序列中最后 n0 个点patch对应的真实点patch "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"P"),s("mi",null,"g")]),s("mi",null,"t")]),s("annotation",{encoding:"application/x-tex"},"P_gt")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9694em","vertical-align":"-0.2861em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"g")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2861em"}},[s("span")])])])])]),s("span",{class:"mord mathnormal"},"t")])])]),t("，生成损失 Lg 使用 Chamfer 距离（CD）的 L1 形式和 L2 形式进行定义，分别记为 Lg1 和 Lg2。")],-1),M=s("p",null,[t("生成损失："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"L"),s("mi",null,"g")]),s("mo",null,"="),s("msubsup",null,[s("mi",null,"L"),s("mn",null,"1"),s("mi",null,"g")]),s("mo",null,"+"),s("msubsup",null,[s("mi",null,"L"),s("mn",null,"2"),s("mi",null,"g")])]),s("annotation",{encoding:"application/x-tex"},"L^g = L^g_1 + L^g_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"L"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6644em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"g")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0486em","vertical-align":"-0.2663em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"L"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7823em"}},[s("span",{style:{top:"-2.4337em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])]),s("span",{style:{top:"-3.1809em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"g")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2663em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0486em","vertical-align":"-0.2663em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"L"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7823em"}},[s("span",{style:{top:"-2.4337em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])]),s("span",{style:{top:"-3.1809em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"g")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2663em"}},[s("span")])])])])])])])])],-1),z=n('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Chamfer 距离（倒角距离）</p><p>是一种衡量两个点云之间距离的指标，用于评估生成的点块与真实点块之间的差异。Lg1 表示使用 L1 形式计算的 Chamfer 距离，而 Lg2 表示使用 L2 形式计算的 Chamfer 距离。</p></div><p>具体而言，生成损失 Lg1 和 Lg2 可以通过计算预测的点块 Ppd 与真实点块 Pgt 之间的 Chamfer 距离来获得。这些损失函数用于衡量生成结果与真实结果之间的差异，以指导生成器的训练。</p><h2 id="experiment" tabindex="-1"><a class="header-anchor" href="#experiment" aria-hidden="true">#</a> Experiment</h2><p><img src="https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826141829290.png" alt="image-20230826141829290"></p><p><img src="https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826141901975.png" alt="image-20230826141901975"></p><p><img src="https://raw.githubusercontent.com/Overmind7/images/main/img/image-20230826141914622.png" alt="image-20230826141914622"></p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h2><p>本文介绍了PointGPT，这是一种<strong>将GPT概念扩展到点云领域的新方法</strong>，<strong>解决了点云的无序性、信息密度差异和生成任务与下游任务之间的差距等挑战</strong>。</p><p>在各种任务上验证了其有效性和强大的泛化能力，表明我们的PointGPT在模型容量相似的单模态方法中表现优异。此外，我们的大规模模型在各种下游任务上取得了SOTA的性能，无需跨模态信息和教师模型的参与。</p><p>尽管PointGPT表现出了良好的性能，但其探索的数据和模型规模仍然比NLP [5; 10]和图像处理 [65; 27] 领域小几个数量级。</p>',10);function N(C,S){const a=r("ExternalLinkIcon");return l(),o("div",null,[m,s("blockquote",null,[s("p",null,[s("a",h,[t("PointGPT: Auto-regressively Generative Pre-training from Point Clouds | Papers With Code"),e(a)])]),s("p",null,[s("a",c,[t("CGuangyan-BIT/PointGPT (github.com)"),e(a)])]),g]),d,s("div",u,[P,_,s("p",null,[s("a",f,[t("最远点采样(Farthest Point Sampling,FPS)算法详解_生信小兔的博客-CSDN博客"),e(a)])])]),v,b,s("div",y,[x,k,T,s("p",null,[s("a",w,[t("莫顿码（Morton code）介绍_点云渣的博客-CSDN博客"),e(a)])])]),L,G,M,z])}const O=i(p,[["render",N],["__file","PointGPT.html.vue"]]);export{O as default};
