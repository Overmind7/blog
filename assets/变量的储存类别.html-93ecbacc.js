import{_ as n,o as s,c as a,e as p}from"./app-04b0d2b0.js";const e={},t=p(`<h1 id="变量的储存类别" tabindex="-1"><a class="header-anchor" href="#变量的储存类别" aria-hidden="true">#</a> 变量的储存类别</h1><h2 id="生存期" tabindex="-1"><a class="header-anchor" href="#生存期" aria-hidden="true">#</a> 生存期</h2><p>除了作用域之外，变量还有另一种属性————<strong>储存期</strong>(storage duration,也称生命期)储存期是指变量在内存中存在的周期（从变量值存在的时间分析）</p><p>分为</p><ul><li>静态储存期（static storage duration）：程序运行期间系统对变量分配固定的储存空间</li><li>动态储存期（dynamic storage duration）：～系统对变量动态地分配储存空间</li></ul><p>内存中用户使用的储存空间分为：</p><ul><li>程序区、</li><li>静态储存区、</li><li>动态储存区</li></ul><p>说明</p><ol><li>程序中所用的数据分别放在静态储存区和动态储存区。</li><li>全局变量全部存放在静态储存区中，程序开始执行的时候就给全局变量分配储存单元，程序执行完毕后释放。在程序执行过程中它们占据固定的储存单元，而不是动态的分配和释放。</li><li>动态储存区中有 <ul><li>函数形式参数：在调用函数时给形参分配储存空间</li><li>函数中定义的变量（未加 static 声明的局部变量）</li><li>函数调用时的现场保护和返回地址等</li></ul></li></ol><p>函数在调用开始时分配动态储存空间，函数调用结束释放</p><p>在函数执行过程中这种分配和释放是动态的：</p><ul><li>如果一个程序中两次调用统一函数，则要进行两次分配和释放，而两次分配给此函数中局部变量的储存空间地址可能是不同的</li><li>如果一个函数中包含多个函数，每个函数的局部变量的储存期并不等于整个程序的执行周期，只是执行周期的一部分，则根据函数调用情况，对局部变量动态地分配和释放储存空间</li></ul><h2 id="储存类别" tabindex="-1"><a class="header-anchor" href="#储存类别" aria-hidden="true">#</a> 储存类别</h2><p>在C++中变量除了有&#39;数据类别&#39;的属性之外,还有<strong>储存类别</strong>（storage class）的属性</p><p>储存类别指的是数据在内存中储存的方法</p><p>储存方法分为<strong>静态储存</strong>和<strong>动态储存</strong>两大类</p><p>按储存类型，可以分为：</p><ul><li><p>内部函数</p></li><li><p>外部函数</p></li></ul><p>储存类别有四种：&#39;<strong>自动的(auto)</strong>&#39;、&#39;<strong>静态的(static)</strong>&#39;、&#39;<strong>寄存器的(register)&#39;</strong>、&#39;<strong>外部的(extern)</strong>&#39;</p><p>根据变量的储存类别，可以知道变量的作用域和储存期</p><h2 id="自动变量-auto-variable-动态局部变量" tabindex="-1"><a class="header-anchor" href="#自动变量-auto-variable-动态局部变量" aria-hidden="true">#</a> 自动变量（auto variable）（动态局部变量）</h2><p>函数中的&#39;局部变量&#39;，如果不用关键字 static 加以声明，编译系统对它们是动态地分配储存空间的</p><p>函数的形参和在函数中定义的变量（包括在复合语句中定义的变量）都属于此类</p><p>在调用该函数时，系统给形参和函数中定义的变量分配存储空间，数据储存在&#39;<strong>动态储存区</strong>中&#39;</p><p>在函数调用结束的时候自动释放这些空间，（在复合语句结束的时候自动释放）</p><p>因此把这类&#39;<strong>局部变量</strong>&#39;，称为&#39;<strong>自动变量</strong>&#39;，用关键字 <strong>auto</strong> 声明</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//定义函数f，a为形参</span>
	<span class="token comment">//定义b和c为整型的自动变量，当f执行完毕之后，自动释放a，b，c所占有的内存</span>
    <span class="token keyword">auto</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>  	
    …………	
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">说明</p><ul><li>储存类别 auto 和数据类型 int 的顺序任意</li><li>关键字 auto 可以省略，如果不写，&#39;默认为自动储存类别&#39; <ul><li>程序中大多数变量属于（默认指定的）自动变量，</li></ul></li></ul></div><h2 id="静态局部变量-static-local-variable" tabindex="-1"><a class="header-anchor" href="#静态局部变量-static-local-variable" aria-hidden="true">#</a> 静态局部变量（static local variable）</h2><p>概念：</p><p>函数中局部变量的值在<strong>函数调用结束之后不消失</strong>，而保留原值（即占用的内存不释放），</p><p>在下一次调用该函数时，该变量保留上一次函数调用结束时的值，</p><p>这时应该指定该局部变量为&#39;静态局部变量&#39;，例</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">auto</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  b <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  c <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token char">&#39;\\t&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>程序分析：</p><p>b = 1; c = 3 + 1; a = 2; return 7</p><p>b = 1; c = 4 + 1; a = 2; return 8</p><p>说明</p><ul><li><p>静态局部变量在静态内存区内分配储存单元。在程序整个运行期间都不释放</p><ul><li>自动变量（动态局部变量）储存在动态储存区空间，调用结束后就释放</li></ul></li><li><p>对静态局部变量是在编译时赋初值，即&#39;<strong>只赋初值一次</strong>&#39;，以后每次调用不是重新赋值，而是保留上一次调用结束时的值</p><ul><li>而对自动变量赋值，不是在编译的时候赋初值，而是在函数调用的时候进行，每调用一次重新赋值</li></ul></li><li><p>如果在定义局部变量时不赋初值：</p><ul><li>静态局部变量： 自动赋初值0（数值型）或者空字符（字符型）</li><li>自动变量： 是一个不确定时值（不可用？）</li></ul></li><li><p>虽然静态局部变量在函数调用结束之后仍然存在，但是&#39;<strong>其他的函数不能引用</strong>&#39;</p><ul><li>(可见性与存在性不一致)</li></ul></li></ul><div class="custom-container tip"><p class="custom-container-title">什么时候使用静态局部变量？</p><p>​ 1、需要保留上一次调用结束时的值，例求 n!</p><p>输出1～5的阶乘值</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//函数声明</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span><span class="token string">&quot;!= &quot;</span><span class="token operator">&lt;&lt;</span><span class="token function">fac</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//f为静态局部变量，函数结束时f的值不释放</span>
  f <span class="token operator">=</span>f <span class="token operator">*</span> n<span class="token punctuation">;</span>       <span class="token comment">//在f原值的基础上乘以n</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 2、如果初始化后，变量只被引用而不改变其值，则这时用静态局部变量比较方便，以免每次调用时重新赋值</p><p>​ 3、注意⚠️：静态局部变量长期占用内存，降低了程序的可读性，因此&#39;如无必要，不要多用静态局部变量&#39;</p></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p><strong>静态成员变量</strong></p><p>将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。</p><p>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。</p><ul><li><p>静态成员变量</p></li><li><ul><li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。 - 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。 - 非静态成员类外不能初始化。 - 静态成员数据是共享的。</li></ul></li></ul><p><strong>静态成员函数</strong></p><p>将类成员函数声明为static，则为静态成员函数。</p><ul><li><p>静态成员函数</p></li><li><ul><li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。 - 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。 - 静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。</li></ul></li></ul></div><h2 id="用-register-声明寄存器变量-对编译系统来说是建议性的而不是强制" tabindex="-1"><a class="header-anchor" href="#用-register-声明寄存器变量-对编译系统来说是建议性的而不是强制" aria-hidden="true">#</a> 用 register 声明寄存器变量（对编译系统来说是建议性的而不是强制）</h2><p>概念：</p><p>一般情况下，变量的值是存放在内存中的。</p><p>当程序要用到哪一个变量时，控制器发出指令将内存中的变量的值送到 cpu 中的运算器，</p><p>如果一些变量使用频繁，为了减少存取变量的时间，Ｃ++允许将局部变量的值放在CPU的寄存器中，不必从内存中存取。</p><p>举例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">register</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span>f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//定义i和f是寄存器变量</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      f <span class="token operator">=</span> f <span class="token operator">*</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p><ul><li>i 和 f 是存放在寄存器的局部变量，若n很大，则能节约很多执行时间</li><li>现在的编译系统的会自动优化，识别使用频繁的变量自动放在寄存器中，不需用户指定</li></ul><h2 id="用-extern-声明外部变量-全局变量" tabindex="-1"><a class="header-anchor" href="#用-extern-声明外部变量-全局变量" aria-hidden="true">#</a> 用 extern 声明外部变量（全局变量）</h2><p>全局变量（外部变量）是在函数的外部定义的，作用域为从变量的定义开始到本程序文件的末尾</p><p>编译时将全局变量分配在静态储存区</p><p>有时需要用 extern 声明全局变量以扩展作用域</p><h3 id="在一个文件内声明全局变量" tabindex="-1"><a class="header-anchor" href="#在一个文件内声明全局变量" aria-hidden="true">#</a> 在一个文件内声明全局变量</h3><p>如果想让定义点之前的函数使用该全局变量，用关键字 extern 对该变量做外部变量声明，表示该变量是一个将在下面定义的全局变量</p><p>也称为&#39;<strong>提前引用声明</strong>&#39;（友元中也出现了？）</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>一般把全局变量定义放在引用它的所有函数之前，可以在函数中避免使用 extern 声明</p></div><p>例，用 extern 对外部变量作提前引用声明，扩展程序文件中的作用域</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//函数声明</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>     <span class="token comment">//对全局变a，b作提前引用声明，如果不用extern，则认为a，b未定义</span>
  cout<span class="token operator">&lt;&lt;</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">;</span>     <span class="token comment">//定义全局变量a，b</span>
<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> z<span class="token punctuation">;</span>
  z <span class="token operator">=</span> x <span class="token operator">&gt;</span> y<span class="token operator">?</span>x<span class="token operator">:</span>y<span class="token punctuation">;</span>
  <span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>15
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="在多文件程序中声明外部变量" tabindex="-1"><a class="header-anchor" href="#在多文件程序中声明外部变量" aria-hidden="true">#</a> 在多文件程序中声明外部变量</h3><p>若一个程序包含两个文件，在两个文件中都要用到同一个外部变量 <code>num</code>：</p><p>正确做法：在任一文件中定义外部变量 <code>num</code>，而在另一个文件中用 extern 对 <code>num</code>做&#39;<strong>外部变量声明</strong>&#39;，即</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译系统现在本文件中寻找，若无则将另一文件中的外部变量 <code>num</code> 的作用域扩展到本文件</p><p>注意： <code>extern</code> 是变量声明，只是对一个已经定义的外部变量作声明，以扩展作用域</p><h2 id="用-static-声明静态外部变量-全局变量" tabindex="-1"><a class="header-anchor" href="#用-static-声明静态外部变量-全局变量" aria-hidden="true">#</a> 用 static 声明静态外部变量（全局变量）</h2><p>1、概念</p><p>有时希望某些外部变量只限于被本文件引用，而不能被其他文件引用</p><p>这时可以在定义外部变量时加一个 <code>static</code> 声明</p><p>例如，在 file1.cpp 中定义了一个全局变量用 <code>static</code> 声明：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时 <code>a</code> 只能用于本文件，即使在 file2.cpp 中用</p><p><code>extern int a;</code> 扩展作用域仍然无法使用 a</p><p>这种加上 static 声明，只能用于本文件的外部变量（全局变量）被称为静态外部变量</p><p>2、用途</p><p>如果已知其他文件不需要引用本文件的全局变量，可以对本文件中的全局变量都加上 static 成为静态外部变量，以免被其他文件误用</p><p>3、注意⚠️</p><ul><li>用 static 声明的外部变量和普通外部变量（全局变量）都采用静态储存方式 <ul><li>只是作用范围不同，都是在编译时分配内存</li></ul></li></ul><h2 id="变量属性小结" tabindex="-1"><a class="header-anchor" href="#变量属性小结" aria-hidden="true">#</a> 变量属性小结</h2><p>page 115</p><h2 id="局部变量和全局变量" tabindex="-1"><a class="header-anchor" href="#局部变量和全局变量" aria-hidden="true">#</a> 局部变量和全局变量</h2><p>作用域：每个变量都用其有效的作用范围，在作用域之外是不能访问这些变量的</p><ul><li>&#39;文件作用域&#39; file scope；（全局的）</li><li>&#39;函数作用域&#39; function scope；</li><li>&#39;块作用域&#39; block scope；</li><li>&#39;函数原型作用域&#39; function prototype scope；</li></ul><p>除了变量之外，任何以标识符代表的实体（如函数、数组、结构体等）都有作用域</p><h3 id="局部变量-local-variable" tabindex="-1"><a class="header-anchor" href="#局部变量-local-variable" aria-hidden="true">#</a> 局部变量（local variable）</h3><p>在一个函数内部定义的变量是，它只在本函数范围内有效。 //在此函数之外是不能够使用这些变量的</p><p>此外，在复合语句中定义的变量，也只在本复合语句中有效。</p><p>这些内部变量被称为&#39;局部变量&#39;</p><p>说明</p><ul><li><p>主函数main定义的变量也只在主函数中有效，也不会在整个程序文件中有效，主函数中也不能使用其他函数中定义的变量（函数平行）</p></li><li><p>不同函数中可以使用同名的变量，代表不同的对象，互不干扰，在内存中占有不同的内存单元</p></li><li><p>在一个函数内部的复合语句中定义变量，只在复合语句中有效，这种复合语句被称为&#39;分程序&#39;或者&#39;程序块&#39;</p></li><li><p>形式参数也是局部变量，其他函数中无效</p></li><li><p>在函数原型中出现的参数名，只在原型声明中的括号范围内有效，并不少实际存在的变量，不能被引用。</p><p>//见函数原型</p><ul><li><strong>&#39;编译系统对函数声明中的变量名是忽略的，即使在调用函数时也没有为它们分配储存单元&#39;</strong></li></ul></li></ul><h3 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量" aria-hidden="true">#</a> 全局变量</h3><p>在函数内定义的变量时局部变量，而在函数之外定义的变量时外部变量，称为全局变量 （global variable）</p><p>有效范围：从定义变量的位置开始，到本文件结束</p><p>说明</p><ul><li><p>全局变量能够增加函数件数据联系到渠道</p><ul><li>同一文件中所有函数都能使用全局变量的值</li><li>如果一个函数改变了全局变量，其他引用同名变量的值也会改变</li><li>函数调用只能带回一个返回值，但是如果在执行的过程中改变了全局变量，&#39;就相当于向main函数传递了更多的数据&#39;</li></ul></li><li><p>建议非必要不使用全局变量</p><ul><li>在程序执行全程都占用内存，而不是仅在需要时开辟内存</li><li>*降低函数通用性 p108 （） <ul><li>一般要求把程序中的函数做成一个封闭体，只有&#39;<strong>实参——形参</strong>&#39;渠道，移植性好，可读性强</li></ul></li><li>全局变量过多降低程序清晰性，容易出错</li></ul></li><li><p>在同一个源文件内，如果全局变量与局部变量同名，则全局变量不起作用，以局部变量为准</p></li><li><p>在有同名全局变量和局部变量的情形时，用 域运算符 提供对全局变量的访问？？</p></li></ul><p>​ 例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>cout<span class="token operator">&lt;&lt;</span><span class="token double-colon punctuation">::</span>count<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span>count<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,102),l=[t];function o(i,c){return s(),a("div",null,l)}const u=n(e,[["render",o],["__file","变量的储存类别.html.vue"]]);export{u as default};
